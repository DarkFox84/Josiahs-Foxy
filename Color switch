/** !!! IF THE PROGRAM WON'T LOAD OR OH NOES SAYS THAT A FOR LOOP IS TAKING TOO LONG TO RUN, CLOSE UNNECESSARY APPLICATIONS, TABS, OR WINDOWS TO FIX THE PROBLEM. !!! 
 * ALSO, DON'T SWITCH BETWEEN TABS IN THE MIDDLE OF A MATCH, OR IT MAY CRASH!
**/
/*
Welcome to Color Arena!
Play against many different AI in an arena survival game (one of the first ones on KA!) with a unique concept! (colors)

This game is very complex, and can be laggy on some devices. If this is the case, close unncessary applications, tabs, or windows to cut down on the lag. Also, never switch between tabs while in the middle of a match.

This game has a save feature! Press SHIFT anytime during the game to generate your save code. Then, copy everything into the below line and save as a spin-off. Don't save in the middle of a match, because it doesn't save in-match stats.
*/
var saveCode = [];
/**
@CREDITS
Credit to OOPS! Studio! for making the loading algorithm. Here's the link to the program I got it from: https://www.khanacademy.org/computer-programming/super-loading-algorithm-free-to-use/6042751651577856
Credit to Sample Text, Kephas Wallace, Programming King, AnimStudioz, and Eternity for Beta Testing
Shuffle function from http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
Raycasting function from: http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
All other code is owned by Plourde27

@INFO
The CPU players' usernames are generated randomly. They have different strategies; some go into the center at the start for the loot, and others flee to far-flung locations on the map.

The maps are generated randomly from 5 different preset map seeds.

@HOW_TO_PLAY
In this game, you are pitted against 11, 17, 23, 35, or 47 CPU players, and the object is to be the last player standing at the end of the game. Chests are located in certain locations throughout the arena, which contain weapons, health packs, and more.
Each player also has a color, and each player starts out with White color. Players can change their color by using potions. Certain zones on the map are only accessible by players of a certain color. Everyone can enter a white zone, nobody can enter a black zone, and all other zones a player can access that zone if they are the same color as the color of the zone. Some color zones may also overlap. In these areas, players who are either one of the colors from the zones may access. For example, there could be an area which is in both a red zone and a green zone. In this case, both red and green players could access. 
When you obtain an item either from a chest or from an eliminated player, a full explanation is available for that item's function.
Chests have a class and a tier.
Class A will contain mostly weapons
Class B will contain mostly health packs and armor
Class C will contain mostly potions (for transformation to another color)
Class D will contain all types of items
Tiers determine how many items are in the chest and how rare those items will be. Tier 1 is the worst, and Tier 5 is the best
Certain very powerful items are Mythical Items and are hard to obtain.
Throughout the match, your character will become thirsty, and you must reach a body of freshwater before you start taking damage.
Also, your character will become hungry, and you must find food from chests to replenish your hunger.
AIs have randomized stats for Strength, Speed, and Stamina. Yours start out at a chosen value, but level up depending on your performance in matches.

I hope you enjoy this game, I have worked very hard on it.
Please give your feedback in the Tips & Thanks section.



@UPDATE_LOG
First work on game: 7/16/18
Beta Release: 11/3/18
Full Release (v1.0.0): 11/5/18

**/



























var BDIST = 1;
var dists = [BDIST * 15000, BDIST * 40000, BDIST * 4800, BDIST * 20000, BDIST * 36000];
var selch = 0;
var saving = false;
var sc = [];
smooth();
var borderDist = 48000;
var generateNoisePos = function(x, y, s) {
    var pos1 = Math.floor(x / s) * s;
    var pos2 = Math.floor(y / s) * s;
    return [[pos1, pos2], [pos1 + s, pos2], [pos1 + s, pos2 + s], [pos1, pos2 + s, s], [pos1 - s, pos2 + s], [pos1 - s, pos2], [pos1 - s, pos2 - s], [pos1, pos2 - s], [pos1 + s, pos2 - s]];
};
var vw = false;
var keywords = ["Bronze", "Silver", "Gold", "Diamond", "Mythical"];
var oldach;
var combos = [];
var pps = [], num = 0, cs = [];
var convertCombo = function(c) {
    num = 0;
    pps = [12, 18, 24, 36, 48];
    cs = [2, 3, 4, 6];
    return cs.indexOf(c) * 4 + pps.indexOf(c);
};
var startingColors;
var splicinds = [];
var wdt;
var shufplayers;
var otplayers;
var menushow = false;
var stgone = false;
var stframe = 0;
var Player1;
var thestatincr = 0;
var thestats = [];
var thestat = thestats[thestatincr];
var ins = [0, 2, 5, 10, 30, 120, 600];
var convertStrength = function(kills, p) {
    var pct = kills / (p - 1);
    if (pct === 0) {
        return ins[0];
    }
    else if (pct < 1/24) {
        return ins[1];
    }
    else if (pct < 1/18) {
        return ins[2];
    }
    else if (pct < 1/14) {
        return ins[3];
    }
    else if (pct < 1/10) {
        return ins[4];
    }
    else if (pct < 1/6) {
        return ins[5];
    }
    else {
        return ins[6];
    }
};

var convertSpeed = function(meters) {
    if (meters < 200) {
        return ins[0];
    }
    else if (meters < 300) {
        return ins[1];
    }
    else if (meters < 800) {
        return ins[2];
    }
    else if (meters < 1500) {
        return ins[3];
    }
    else if (meters < 2500) {
        return ins[4];
    }
    else if (meters < 4000) {
        return ins[5];
    }
    else {
        return ins[6];
    }
};

var convertStamina = function(time) {
    if (time < 15) {
        return ins[0];
    }
    else if (time < 75) {
        return ins[1];
    }
    else if (time < 180) {
        return ins[2];
    }
    else if (time < 300) {
        return ins[3];
    }
    else if (time < 450) {
        return ins[4];
    }
    else if (time < 600) {
        return ins[5];
    }
    else {
        return ins[6];
    }
};

var statlevels = [10, 20, 50, 100, 200, 500, 1000, 2000, 4000, 6000, 8000, 12000];

var pref = function(num) {
    num = num.toString().split("");
    if (num.length > 1) {
        if (num[num.length - 2] === "1") {
            return "th";
        }
    }
    if (num[num.length - 1] === "1") {
        return "st";
    }
    else if (num[num.length - 1] === "2") {
        return "nd";
    }
    else if (num[num.length - 1] === "3") {
        return "rd";
    }
    else {
        return "th";
    }
};
var playerplace = 2;
var win = false;
var oldpn;
var oldcn;
var elimd = false;
var money = 100;
var matchtime;
var validTrees = [];
var ps = second();
var countdown = 5;
var paused = false;
var sf = 0.03;
var startMapTransition = false;
var loadTransitionPos = [-600, 2100];
var cloud = function(x, y) {
    fill(255, 255, 255);
    noStroke();
    translate(0, -24.5);
    rect(x, y + 50, 100, 30);
    ellipse(x - 50, y + 35, 60, 60);
    ellipse(x - 30, y + 15, 60, 60);
    ellipse(x - 10, y + 5, 50, 50);
    ellipse(x - 10, y + 35, 40, 40);
    ellipse(x + 15, y + 20, 35, 35);
    ellipse(x + 50, y + 40, 50, 50);
    ellipse(x + 40, y + 20, 30, 30);
    ellipse(x + 25, y + 5, 30, 30);
    ellipse(x + 15, y - 5, 25, 25);
    resetMatrix();
};

var bird = function(x, y) {
    resetMatrix();
    pushMatrix();
    translate(x, y);
    scale(0.3);
    translate(-x, -y);
    var co = [color(10, 10, 107), color(13, 79, 34), color(107, 5, 5)];
    var birdco = co[round(random(-0.4, co.length - 0.6))];
    fill(birdco);
    stroke(0, 0, 0);
    strokeWeight(1);
    beginShape();
    vertex(x - 20, y - 18);
    vertex(x - 15, y);
    vertex(x - 15, y + 5);
    vertex(x + 20, y + 5);
    vertex(x + 20, y - 12);
    vertex(x + 10, y - 12);
    vertex(x + 10, y);
    vertex(x - 10, y - 20);
    vertex(x - 5, y);
    vertex(x - 10, y);
    vertex(x - 12, y - 5);
    endShape();
    arc(x + 2.5, y + 5, 35, 10, 0, 180);
    arc(x + 15, y - 12, 10, 10, 180, 360);
    stroke(birdco);
    strokeWeight(2);
    line(x - 14, y + 5, x + 18, y + 5);
    line(x + 12.2, y - 12, x + 16.2, y - 12);
    strokeWeight(1);
    noStroke();
    fill(255, 255, 255);
    ellipse(x + 15, y - 12, 7, 7);
    fill(0, 0, 0);
    ellipse(x + 17, y - 12, 3, 3);
    triangle(x + 20, y - 10, x + 25, y - 6, x + 20, y - 2);
    popMatrix();
    resetMatrix();
};

var tree = function(x, sz) {
    resetMatrix();
    pushMatrix();
    translate(x, 570);
    scale(sz);
    translate(-x, -570);
    fill(80, 50, 0);
    beginShape();
    vertex(x - 10, 570);
    vertex(x - 10, 370);
    vertex(x + 10, 370);
    vertex(x + 10, 570);
    endShape();
    fill(50, 97, 38);
    stroke(0, 0, 0);
    strokeWeight(1);
    beginShape();
    vertex(x - 10, 530);
    for (var i = 530 ; i > 370 ; i -= 20) {
        vertex(x - 10, i);
        vertex(x - 30 - ((i - 370) / 20) * 6, i + 20);
    }
    vertex(x - 10, 370);
    vertex(x, 365);
    vertex(x + 10, 370);
    for (var i = 370 ; i < 530 ; i += 20) {
        vertex(x + 10, i);
        vertex(x + 30 + ((i - 370) / 20) * 6, i + 40);
    }
    vertex(x + 10, 530);
    endShape();
    popMatrix();
    resetMatrix();
};
var oldtrees = [[0, 0]];
var orgframe;
var lf = 0;
var paths = [];
var mapFinished = false;
var drawGrass = function(x, y) {
    stroke(255, 255, 0);
    strokeWeight(3);
    line(x - 5, y + 8, x - 7, y - 12);
    line(x, y + 8, x, y - 18);
    line(x + 5, y + 8, x + 7, y - 15);
};
var imgs = {
    bcg1: {
        w: 600,
        h: 600,
        d: function() {
            fill(159, 222, 230);
            noStroke();
            rect(300, 300, 600, 600);
            for (var i = 0 ; i < random(3, 12) ; i ++) {
                cloud(random(0, 600), random(50, 250));
            }
            for (var i = 150 ; i > 100 ; i --) {
                fill(255, 255, 0, (i - 100) * (50 / 255));
                ellipse(150, 100, i, i);
            }
            fill(255, 255, 0);
            ellipse(150, 100, 100, 100);
            fill(87, 184, 87);
            rect(300, 585, 600, 30);
            for (var i = 0 ; i < 1.5 ; i += 0.4) {
                tree(random(0, 300), i);
                tree(random(0, 300), i);
                tree(random(0, 300), i);
            }
            fill(29, 39, 153);
            arc(920, 570, 1200, 200, 0, 180);
            noStroke();
            beginShape();
            for (var i = 320 ; i < 700 ; i += 50) {
                vertex(i, 570);
                vertex(i + 12.5, 568);
                vertex(i + 25, 562);
                vertex(i + 37.5, 568);
                vertex(i + 50, 570);
                vertex(i, 570);
            }
            endShape();
            for (var i = 0 ; i < random(7, 12) ; i++) {
                bird(random(0, 600), random(0, 400));
            }
            filter(BLUR, 3);
        }
    },
    bcg2: {
        w: 600,
        h: 600,
        d: function() {
            fill(159, 222, 230);
            noStroke();
            rect(300, 300, 600, 600);
            for (var i = 0 ; i < random(3, 12) ; i ++) {
                cloud(random(0, 600), random(50, 250));
            }
            for (var i = 150 ; i > 100 ; i --) {
                fill(255, 255, 0, (i - 100) * (50 / 255));
                ellipse(150, 100, i, i);
            }
            fill(255, 255, 0);
            ellipse(150, 100, 100, 100);
            fill(87, 184, 87);
            rect(300, 585, 600, 30);
            for (var i = 0 ; i < 1.5 ; i += 0.2) {
                tree(random(0, 600), i);
                tree(random(0, 600), i);
                tree(random(0, 600), i);
            }
            for (var i = 0 ; i < random(7, 12) ; i++) {
                bird(random(0, 600), random(0, 400));
            }
            filter(BLUR, 3);
        }
    },
    bcg3: {
        w: 600,
        h: 600,
        d: function() {
            fill(159, 222, 230);
            noStroke();
            rect(300, 300, 600, 600);
            for (var i = 0 ; i < random(3, 12) ; i ++) {
                cloud(random(0, 600), random(50, 250));
            }
            for (var i = 150 ; i > 100 ; i --) {
                fill(255, 255, 0, (i - 100) * (50 / 255));
                ellipse(150, 100, i, i);
            }
            fill(255, 255, 0);
            ellipse(150, 100, 100, 100);
            fill(87, 184, 87);
            rect(300, 585, 600, 30);
            for (var i = 0 ; i < random(33, 40) ; i++) {
                resetMatrix();
                var randf = random(0, 600);
                pushMatrix();
                translate(randf, 570);
                scale(1.5);
                translate(-randf, -570);
                drawGrass(randf, random(560, 570));
            }
            for (var i = 0 ; i < random(7, 12) ; i++) {
                bird(random(0, 600), random(0, 400));
            }
            filter(BLUR, 3);
        }
    },
    bcg4: {
        w: 600,
        h: 600,
        d: function() {
            fill(159, 222, 230);
            noStroke();
            rect(300, 300, 600, 600);
            for (var i = 0 ; i < random(3, 12) ; i ++) {
                cloud(random(0, 600), random(50, 250));
            }
            for (var i = 150 ; i > 100 ; i --) {
                fill(255, 255, 0, (i - 100) * (50 / 255));
                ellipse(150, 100, i, i);
            }
            fill(255, 255, 0);
            ellipse(150, 100, 100, 100);
            fill(87, 184, 87);
            rect(300, 585, 600, 30);
            for (var i = 0 ; i < random(33, 40) ; i++) {
                resetMatrix();
                var randf = random(200, 400);
                pushMatrix();
                translate(randf, 570);
                scale(1.5);
                translate(-randf, -570);
                drawGrass(randf, random(560, 570));
            }
            for (var i = 0 ; i < random(5, 12) ; i++) {
                tree(random(0, 150), random(0.2, 1.3));
            }
            fill(29, 39, 153);
            noStroke();
            arc(1020, 570, 1200, 200, 0, 180);
            beginShape();
            for (var i = 420 ; i < 700 ; i += 50) {
                vertex(i, 570);
                vertex(i + 12.5, 568);
                vertex(i + 25, 562);
                vertex(i + 37.5, 568);
                vertex(i + 50, 570);
                vertex(i, 570);
            }
            endShape();
            for (var i = 0 ; i < random(7, 12) ; i++) {
                bird(random(0, 600), random(0, 400));
            }
            filter(BLUR, 3);
        }
    },
    bcg5: {
        w: 600,
        h: 600,
        d: function() {
            fill(159, 222, 230);
            noStroke();
            rect(300, 300, 600, 600);
            for (var i = 0 ; i < random(3, 12) ; i ++) {
                cloud(random(0, 600), random(50, 250));
            }
            for (var i = 150 ; i > 100 ; i --) {
                fill(255, 255, 0, (i - 100) * (50 / 255));
                ellipse(150, 100, i, i);
            }
            fill(255, 255, 0);
            ellipse(150, 100, 100, 100);
            //noLoop();
            fill(87, 184, 87);
            rect(300, 585, 600, 30);
            
            fill(29, 39, 153);
            noStroke();
            rect(300, 585, 600, 30);
            beginShape();
            for (var i = 0 ; i < 700 ; i += 50) {
                vertex(i, 570);
                vertex(i + 12.5, 568);
                vertex(i + 25, 562);
                vertex(i + 37.5, 568);
                vertex(i + 50, 570);
                vertex(i, 570);
            }
            endShape();
            fill(214, 186, 137);
            ellipse(300, 800, 800, 500);
            for (var i = 0 ; i < random(7, 12) ; i++) {
                bird(random(0, 600), random(0, 400));
            }
            tree(300, 1);
            filter(BLUR, 3);
        }
    },
    tree: {
        w: 100,
        h: 100,
        d: function() {
            background(0, 0, 0, 0);
            /*translate(0, -10);
            scale(1 / 6);
            rectMode(CENTER);
            fill(8, 64, 22);
            noStroke();
            fill(219, 171, 76);
            for (var i = 0 ; i < 90 ; i += 2) {
                fill(219 - i, 171 - i, 76 - i / 2);
                rect(300, 506, 100 * cos(i), 200);
            }
            for (var l = 5 ; l > 0 ; l--) {
                for (var k = 100 ; k > 0 ; k -= 10) {
                    fill(8 + (100 - k), 64 + (100 - k), 22 + (100 - k));
                    ellipse(300, 100 + l * 50, l * (2/3) * k, l * k / 2);
                }
            }
            resetMatrix();*/
            noStroke();
            translate(-170, -170);
            for (var j = 60 ; j > 0 ; j -= 20) {
                for (var i = j ; i > 0 ; i -= j / 20) {
                    var inum = i / (j / 20);
                    fill(0, 150 - inum * 3, 0);
                    ellipse(200, 200, i, i);
                }
            }
            resetMatrix();
        }
    },
    chest1: {
        w: 60,
        h: 60,
        d: function() {
            fill(77, 11, 6, 200);
            beginShape();
            vertex(30 - 14, 30 - 4);
            vertex(30 - 10, 30);
            vertex(30 - 20, 30 + 7);
            vertex(30 - 18, 30 + 9);
            vertex(30 - 8, 30 + 2);
            vertex(30 - 2, 30 + 7);
            vertex(30, 30 + 6);
            vertex(30 - 14, 30 - 6);
            vertex(30 - 16, 30 - 4);
            endShape();
            fill(150, 150, 150, 200);
            beginShape();
            vertex(30 - 6, 30);
            vertex(30 + 23, 30 - 21);
            vertex(30 + 26, 30 - 26);
            vertex(30 + 21, 30 - 23);
            vertex(30 - 8, 30 - 2);
            vertex(30 - 6, 30);
            endShape();
        }
        
    },
    chest2: {
        w: 60,
        h: 60,
        d: function() {
            fill(255, 0, 0, 200);
            beginShape();
            vertex(30 - 15, 30 - 10);
            vertex(30 - 5, 30 - 10);
            vertex(30 - 5, 30 - 20);
            vertex(30 + 5, 30 - 20);
            vertex(30 + 5, 30 - 10);
            vertex(30 + 15, 30 - 10);
            vertex(30 + 15, 30);
            vertex(30 + 5, 30);
            vertex(30 + 5, 30 + 10);
            vertex(30 - 5, 30 + 10);
            vertex(30 - 5, 30);
            vertex(30 - 15, 30);
            vertex(30 - 15, 30 - 10);
            endShape();
        }
    },
    chest3: {
        w: 60,
        h: 60,
        d: function() {
            fill(0, 255, 0, 200);
            noStroke();
            rect(30, 30 - 5, 10, 10);
            stroke(0, 0, 0);
            strokeWeight(2);
            arc(30, 30, 10, 10, 0, 180);
            line(30 - 5, 30, 30 - 5, 30 - 15);
            line(30 + 5, 30, 30 + 5, 30 - 15);
            strokeWeight(1);
            line(30 - 5, 30 - 15, 30 + 5, 30 - 15);
        }
    },
    chest4: {
        w: 60,
        h: 60,
        d: function() {
            fill(77, 11, 6, 200);
            beginShape();
            vertex(30 - 14, 30 - 4);
            vertex(30 - 10, 30);
            vertex(30 - 20, 30 + 7);
            vertex(30 - 18, 30 + 9);
            vertex(30 - 8, 30 + 2);
            vertex(30 - 2, 30 + 7);
            vertex(30, 30 + 6);
            vertex(30 - 14, 30 - 6);
            vertex(30 - 16, 30 - 4);
            endShape();
            fill(150, 150, 150, 200);
            beginShape();
            vertex(30 - 6, 30);
            vertex(30 + 23, 30 - 21);
            vertex(30 + 26, 30 - 26);
            vertex(30 + 21, 30 - 23);
            vertex(30 - 8, 30 - 2);
            vertex(30 - 6, 30);
            endShape();
            fill(255, 0, 0, 200);
            beginShape();
            vertex(30 - 5, 30 - 10);
            vertex(30 + 5, 30 - 10);
            vertex(30 + 5, 30 - 20);
            vertex(30 + 15, 30 - 20);
            vertex(30 + 15, 30 - 10);
            vertex(30 + 25, 30 - 10);
            vertex(30 + 25, 30);
            vertex(30 + 15, 30);
            vertex(30 + 15, 30 + 10);
            vertex(30 + 5, 30 + 10);
            vertex(30 + 5, 30);
            vertex(30 - 5, 30);
            vertex(30 - 5, 30 - 10);
            endShape();
            fill(0, 255, 0, 200);
            noStroke();
            rect(30 - 20, 30 - 5, 10, 10);
            stroke(0, 0, 0);
            strokeWeight(2);
            arc(30 - 20, 30, 10, 10, 0, 180);
            line(30 - 25, 30, 30 - 25, 30 - 15);
            line(30 - 15, 30, 30 - 15, 30 - 15);
            strokeWeight(1);
            line(30 - 25, 30 - 15, 30 - 15, 30 - 15);
        }
    }
};
var curLoad = 0;
var load = function() {
    var img = imgs[Object.keys(imgs)[curLoad]];
    background(0, 0, 0, 0);
    img.d();
    if (img.x) {
        imgs[Object.keys(imgs)[curLoad]] = get(img.x, img.y, img.w, img.h);
    }
    else {
        imgs[Object.keys(imgs)[curLoad]] = get(0, 0, img.w, img.h);
    }
    background(0, 0, 0, 0);
    fill(0, 0, 0);
    textSize(60);
    textFont(createFont("Avenir"));
    text("LOADING", 300, 200);
    text((curLoad / 10) * 100 + "% Loaded", 300, 400);
    curLoad++;
};
var clicked = false;
mouseClicked = function() {
    clicked = true;
};

var messages = [];
//From http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
var shuffle = function(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;
  // While there remain elements to shuffle...
  while (0 !== currentIndex) {
    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
};

var numsArr = [];
for (var i = 0 ; i < 500 ; i++) {
    numsArr.push(i);
}
var colortf = 0;

var chestClicked = false;

var invInd;
var invW;
var invH;
var invX;
var invY;
var invIcon;

var invtf = 255;

var colorNum;

var displayed = false;

var aipos;

var playerNum;

rectMode(CENTER);
textFont(createFont("AvenirNext-UltraLight"));
textAlign(CENTER, CENTER);

var pressed, clicked, spacePressed, spaceClicked = false;

var keys = [];
var spacepressed = false;
var pclicked = false;
keyPressed = function() {
    keys[keyCode] = true;
    if (keys[32]) {
        spacepressed = true;
    }
    pclicked = true;
};

keyReleased = function() {
    keys[keyCode] = false;
};

var frame = 0;

var ticks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

var messageTick = 0;

var drawMessages = function() {
    textFont(createFont("Avenir"));
    for (var i = 0 ; i < messages.length ; i++) {
        fill(55, 55, 55, 125);
        noStroke();
        rectMode(LEFT);
        rect(580 - messages[i][0].length * 9.15, 100 + i * 25 - 10, messages[i][0].length * 9.15, 20);
        textSize(15);
        fill(255, 255, 255);
        textAlign(LEFT, CENTER);
        text(messages[i][0], 580 - messages[i][0].length * 9.15 + 5, 100 + i * 25);
        textAlign(CENTER, CENTER);
        rectMode(CENTER);
        if (messageTick > messages[i][1] + 300) {
            messages.splice(i, 1);
        }
    }
};

var page = 1;
var instr = ["Welcome to Color Arena!\n\nThis is my 30th game, and by far my largest and best game.\n\nUse the buttons to move between pages of the instructions.", "When playing, use the up arrow key to move forward, and the left and right keys to turn.", "Color Arena is an arena game. A certain number of players (usually 24) are put in an arena with chests with various useful items. The goal is to be the last player standing.\n\nSince Khan Academy does not support multiplayer interaction, the other players are computer-controlled, and are intelligent and designed to be similar to a real player of the game.", "The map is chosen randomly from 5 preset maps. Some maps include forests, others plains or lakes.", "Each player has a color. At the start of the match, each player has White color. A player's color is changed using potions. Every Map includes color zones. In most zones, such as a Red zone, only players of red color could enter. However, all players are allowed in white zones, and none are allowed in black zones.", "The most chests are located near the center of the map, but some are located on the outside as well.\n\nTo open a chest, press ENTER or X when you are standing on the chest.", "Each chest has a tier and a class. The tier ranges from 1 to 5, with 1 the worst and 5 the best.\nThe Class can be A, B, C, or D.\nClass A will contain more weapons, such as swords or bows.\nClass B will contain more healing items, such as health packs.\nClass C will contain items used for transformation into other colors, such as potions.\nClass D chests will contain many different items.", "When a player is eliminated (by thirst, a color zone, or another player), most of their inventory is dropped onto the ground. When you are next to a dropped item, press SHIFT to pick it up.", "Some maps include forests. In forests, you move slightly slower. However, if you are on a path through the forest you can move faster.", "Over time, your player will get hungry and thirsty.\nFood can only be obtained from chests.\nHowever, water can be obtained from lakes.", "Lakes are located somewhere in every map. You can only cross them in a boat, and they provide drinking water.", "In some maps, boats are already placed in lakes for players to use to traverse the lake. Boats are never found in chests. Press SPACE to get in or out of a boat.", "The border of the map is constantly shrinking, and players who are caught in the black zone outside of the border will suffer intense damage.", "In between matches, your stats for Strength, Speed, and Stamina will fluctuate depending on your performance. You can buy new characters in the shop that may have better attributes.", "That's it for the instructions! Good luck, and enjoy the game!"];
var strength = 4;
var attrspeed = 4;
var stamina = 4;
var nam = ["Strength", "Speed", "Stamina"];
var stcol = [color(125, 0, 0), color(0, 125, 0), color(0, 0, 125)];
var characterNames = ["Basic", "Boxer", "Survivor", "Sprinter", "Athlete", "Ninja"];
var characterStats = [[0, 0, 0], [4, 0, 0], [0, 2, 3], [0, 4, 2], [3, 3, 2], [2, 4, 4]];
var pos = [[100, 230], [300, 230], [500, 230], [100, 360], [300, 360], [500, 360]];
var charselected = 0;
var money = 0;
var owned = [true, false, false, false, false, false];
var characterDescriptions = ["The classic character.", "Has very high strength.", "Has medium speed and high stamina.", "Has very high speed and medium stamina.", "Has high strength, high speed, and medium stamina.", "As stealthy as a ninja! Has medium strength, very high speed, and very high stamina."];
var costs = [0, 250, 300, 350, 500, 800];
var doneMatch = false;
var startingPlayers;
var achievementColors = [color(156, 83, 34), color(107, 108, 128), color(219, 197, 52), color(80, 222, 210), color(0, 0, 0)];
var achievementColors2 = [color(146, 73, 24), color(97, 98, 118), color(209, 187, 42), color(70, 212, 200), color(20, 20, 20)];
var achievementColors3 = [color(166, 93, 44), color(117, 118, 138), color(229, 207, 62), color(90, 232, 220), color(30, 30, 30)];
var nonAchievementNames = ["Bronze", "Silver", "Gold", "Diamond", "Mythical"];
var textAchievementNames = ["BRONZE", "SILVER", "GOLD", "DIAMOND", "MYTHICAL"];
var achievementNames = ["BRONZE ACHIEVEMENTS", "SILVER ACHIEVEMENTS", "GOLD ACHIEVEMENTS", "DIAMOND ACHIEVEMENTS", "MYTHICAL ACHIEVEMENTS"];
var matchPlayed = false, rookieBuyer = false, coloring = false, moreThanHalf = false, amateurHunter = false, crowded = false, frequentPlayer = false, play5 = false, gettingRich = false, cleric = false, topOfTheCharts = false, hunter = false, winner = false, bigBuyer = false, dragonsPowers = false, pacifist = false, savage = false, silver = false, ultraWinner = false, veryBigBuyer = false, mythicalPowers = false, fastWorker = false, savage2 = false, overachiever = false;
var achievements = [["Getting Started", "Play 1 Match", false], ["Rookie Buyer", "Buy a new character in the Shop", false], ["Coloring", "Enter a Color Zone", false], ["More than Half", "Place in the top 50% of a match", false], ["Amateur Hunter", "Eliminate another player", false], ["Crowded", "Place in the top 32 of a 48-Player match", false], ["Frequent Player", "Play 5 Matches", false], ["Getting Rich", "Have 500 dollars at one time", false], ["Cleric", "Heal yourself with a full health pack", false], ["Top of the Charts", "Place in the top 5 of a match with at least 24 players", false], ["Hunter", "Make 3 kills in one match", false], ["Bronze", "Earn all Bronze achievements", false], ["Winner", "Win a match", false], ["Big Buyer", "Buy 3 characters in the shop", false], ["Dragon’s Powers", "Eliminate another player with a Mythical Dragon’s Sword", false], ["Pacifist", "Come in the top 3 of a match without any kills", false], ["Savage", "Make 20 total kills", false], ["Silver", "Earn all Silver achievements", false], ["Ultra Winner", "Win 3 matches with 48 players", false], ["Very Big Buyer", "Buy all characters in the shop", false], ["Mythical Powers", "Unlock mythical powers by posessing all 3 fangs", false], ["Fast Worker", "Win a match in under 5 minutes", false], ["Savage 2.0", "Make 10 kills in one match", false], ["Golden Age", "Earn all Gold achievements", false], ["Overachiever", "Earn all Diamond achievements. You have beaten the game! Congratulations! You can continue playing matches as much as you like.", false]];
var achl = [];

var unlock = function(ach) {
    if (!achievements[ach][2]) {
        messages.push([keywords[Math.floor(ach / 6)] + " Achievement Unlocked: " + achievements[ach][0] + "!", messageTick]);
        
    }
    achievements[ach][2] = true;
    
};

var drawAchievement = function(x, y, a) {
    translate(x, y);
    scale(0.6);
    translate(-x, -y);
    translate(0, -14);
    
    fill(achievementColors[a]);
    noStroke();
    beginShape();
    vertex(x + 3, y + 40);
    vertex(x + 20, y + 40);
    vertex(x + 20, y + 50);
    vertex(x - 20, y + 50);
    vertex(x - 20, y + 40);
    vertex(x - 3, y + 40);
    vertex(x - 3, y + 8);
    vertex(x + 3, y + 8);
    
    endShape();
    arc(x, y - 15, 43, 64, 0, 180);
    noFill();
    stroke(achievementColors2[a]);
    strokeWeight(4);
    arc(x, y - 15, 41, 62, 0, 180);
    line(x - 21, y - 15, x - 21, y - 22);
    line(x + 21, y - 15, x + 21, y - 22);
    fill(achievementColors3[a]);
    noStroke();
    textSize(7.5);
    textFont(createFont("AvenirNext-Bold"));
    textAlign(CENTER, CENTER);
    text(textAchievementNames[a], x, y + 45);
    resetMatrix();
};

//sc = [scene === "Play", achl, Player1.x, Player1.y, Player1.Pinventory, Player1.strength, Player1.speed, Player1.stamina, owned, money, money + 797, Player1.incr[0], Player1.incr[1], Player1.incr[2], Player1.totalKills, frequentPlayer, ultraWinner];
var tk = 0;
var inp = [0, 0, 0];
var stats = [4, 4, 4];
var cheater = false;
var instructionsRead = false;
var showInstructions = false;
var nextScene = "Logo";
if (saveCode.length > 0) {
    instructionsRead = true;
    nextScene = "Welcome";
    for (var i = 1 ; i < 26 ; i++) {
        achievements[i - 1][2] = saveCode[i];
    }
    stats = [saveCode[55], saveCode[56], saveCode[57]];
    owned = [saveCode[58], saveCode[59], saveCode[60], saveCode[61], saveCode[62], saveCode[63]];
    money = saveCode[65] - 797;
    if (saveCode[65] + 797 !== saveCode[64]) {
        cheater = true;
    }
    inp = [saveCode[66], saveCode[67], saveCode[68]];
    tk = saveCode[69];
    frequentPlayer = saveCode[70];
    ultraWinner = saveCode[71];
}
var scene = "Loading";
var oldscene = scene;
var imgs1 = [];
var imgs2 = [];
var choptf = 0;
var orgpos = [[0, 0], [300, 0], [300, 300], [0, 300]];
var dir = [[-1, -1], [1, -1], [1, 1], [-1, 1]];
var diagpos = 300;
var mode = 0;
var tincr = 10;
var transitioning = false;
var allimgs = [function() { image(imgs.bcg1, 0, 0); }, function() { image(imgs.bcg2, 0, 0); }, function() { image(imgs.bcg3, 0, 0); }, function() { image(imgs.bcg4, 0, 0); }, function() { image(imgs.bcg5, 0, 0); }];
var timg = round(random(-0.4, 4.4));
var newscene = scene;
var clickFrame = 1;
var nodes = [];
var cdist = 0;
var logoang = 0;
var speed = 1;
var speed2 = 10;
textFont(createFont("Avenir"));
var ppos = -500;
var logotpf = 0;
rectMode(CENTER);
var logops = [];
for (var i = 0 ; i < 25 ; i++) {
    var lrf = random(0, 360);
    logops.push([random(-200, 800), random(-200, 800), [random(0, 255), random(0, 255), random(0, 255)], cos(lrf) * 3, sin(lrf) * 3]);
}
var Logo = function() {
    background(255, 255, 255);
    for (var i = 0 ; i < logops.length ; i++) {
        for (var j = 80 ; j > 50 ; j -= 5) {
            fill(logops[i][2][0], logops[i][2][1], logops[i][2][2], 255 - ((j - 50) * (255 / 30)));
            ellipse(logops[i][0] + cos(frameCount) * 100, logops[i][1] + cos(frameCount) * 100, j, j);
        }   
        logops[i][0] += logops[i][3];
        logops[i][1] += logops[i][4];
        if (logops[i][0] < -200) {
            logops[i][0] = 800;
        }
        if (logops[i][1] > 800) {
            logops[i][0] = -200;
        }
        if (logops[i][1] < -200) {
            logops[i][1] = 800;
        }
        if (logops[i][1] > 800) {
            logops[i][1] = -200;
        }
    }
    fill(255, 255, 255, 80);
    noStroke();
    rect(300, 300, 600, 600);
    stroke(0, 0, 255, 100);
    strokeWeight(5);
    for (var i = 0 ; i < nodes.length ; i++) {
        if (i !== 0) {
            line(nodes[i][0], nodes[i][1], nodes[i - 1][0], nodes[i - 1][1]);
        }
    }
    if (cdist > 120) {
        if (ppos < 0) {
            ppos += 5;
        }
        
    }
    if (cdist < 150) {
        for (var i = 0 ; i < speed2 ; i++) {
            nodes.push([300 + cos(logoang) * cdist, 300 + sin(logoang) * cdist]);
            logoang += speed/* / ((dist(nodes[nodes.length - 1][0], nodes[nodes.length - 1][1], 300, 300) / 100) + 0.01);
            cdist += 0.2*/;
            cdist += speed * 0.08;
        }
    }
    else if (logotpf < 150) {
        logotpf += 3;
    }
    if (logotpf > 250) {
        scene = "Menu";
        textAlign(CENTER, CENTER);
    }
    fill(255, 255, 255, logotpf);
    noStroke();
    rect(300, 300, 600, 600);
    fill(0, 0, 0);
    textSize(100);
    textAlign(CENTER, BASELINE);
    text("PLOURDE27", 300, 300 + ppos);
    textAlign(CENTER, TOP);
    textSize(60);
    text("PROGRAMMING", 300, 300 - ppos);
    //nodes.push([300 + cos(frameCount * 3 * (1 / ()) * (frameCount / 10), 300 + sin(frameCount * 3) * (frameCount / 10), 5, 5]);
    //ellipse(300 + cos(frameCount * 3) * (frameCount / 10), 300 + sin(frameCount * 3) * (frameCount / 10), 5, 5);
};
var colors = [color(255, 0, 0, 200), color(0, 255, 0, 200), color(0, 0, 255, 200), color(255, 255, 0, 200), color(255, 0, 255, 200), color(255, 125, 0, 200), color(0, 0, 0, 200)];
colors[-1] = color(255, 255, 255, 200);
var arrColors = [[255, 0, 0, 200], [0, 255, 0, 200], [0, 0, 255, 200], [255, 255, 0, 200], [255, 0, 255, 200], [255, 125, 0, 200], [0, 0, 0, 200]];
arrColors[-1] = [255, 255, 255, 200];
var colorWords = [];

var Player1;

var Collide = function(obj1, obj2) {
    if (dist(obj1.x, obj1.y, obj2.x, obj2.y) < 30) {
        return true;
    }
    strokeWeight(1);
    stroke(0, 0, 0);
    //line(obj1.x, obj1.y, obj2.x, obj2.y);
};

var  inside = function(point, vs) {
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

    var x = point[0], y = point[1];

    var inside = false;
    for (var i = 0, j = vs.length - 1; i < vs.length; j = i ++) {
        var xi = vs[i][0], yi = vs[i][1];
        var xj = vs[j][0], yj = vs[j][1];

        var intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) {inside = !inside;}
    }

    return inside;
};

var CalculateAngle = function(x1, x2, y1, y2) {
    var ang = atan((y2 - y1) / (x2 - x1));
    if (x1 < x2) {
        ang += 180;
    }
    while (ang < 0) {
        ang += 360;
    }
    while (ang > 360) {
        ang -= 360;
    }
    return ang;
};

var players;

var ang = 0;
var itemList;

var potionImage = createGraphics(200, 200, JAVA2D);

if (potionImage) {
    potionImage.noStroke();
    //potionImage.fill(200, 200, 200);
    //potionImage.rect(0, 0, 200, 200);
    potionImage.background(0, 0, 0, 0);
    potionImage.translate(-200, -250);
    for (var i = 450 ; i > 250 ; i -= 0.5) {
        potionImage.strokeWeight(5);
        if (i > 350) {
            potionImage.stroke((390 - i) * (255 / 30), 255 - (420 - i) * (255 / 30), (450 - i) * (255 / 30));
        }
        else {
            potionImage.stroke(255 - (280 - i) * (255 / 30), (320 - i) * (255 / 30), 255 - (350 - i) * (255 / 30));
        }
        if (i > 350) {
            var cosf = cos(cos((i - 350) / 2) * (90 / 100) * 180);
            potionImage.line(300 - cosf * 100, i, 300 + cosf * 100, i);
        }
        else {
            potionImage.line(200, i, 400, i);
        }
    }
}

var compassCodes = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];

var compassImage = createGraphics(600, 600, JAVA2D);

/*if (compassImage) {
    compassImage.background(0, 0, 0, 0);
    compassImage.angleMode = "degrees";
    compassImage.textAlign(CENTER, CENTER);
    compassImage.fill(55, 55, 55);
    compassImage.stroke(0, 0, 0);
    compassImage.strokeWeight(10);
    compassImage.ellipse(300, 300, 400, 400);
    compassImage.stroke(255, 255, 255);
    compassImage.strokeWeight(3);
    for (var i = 100 ; i < 460 ; i += 20) {
        compassImage.line(300 + cos(i) * 195, 300 + sin(i) * 195, 300 + cos(i) * 160, 300 + sin(i) * 160);
        for (var j = 2 ; j < 20 ; j += 2) {
            if (j === 10) {
                compassImage.line(300 + cos(i + j) * 195, 300 + sin(i + j) * 195, 300 + cos(i + j) * 180, 300 + sin(i + j) * 180);
                compassImage.fill(255, 255, 255);
                compassImage.textSize(15);
                compassImage.textFont(createFont("monospace"));
                compassImage.pushMatrix();
                compassImage.translate(300 + cos(i + j) * 165, 300 + sin(i + j) * 165);
                compassImage.rotate(i + j + 90);
                compassImage.translate(-300 - cos(i + j) * 165, -300 - sin(i + j) * 165);
                compassImage.text((i + j + 90) % 360, 300 + cos(i + j) * 165, 300 + sin(i + j) * 165);
                compassImage.popMatrix();
            }
            else {
                compassImage.line(300 + cos(i + j) * 195, 300 + sin(i + j) * 195, 300 + cos(i + j) * 186, 300 + sin(i + j) * 186);
            }
        }
    }
    compassImage.noFill();
    compassImage.stroke(0, 0, 0);
    compassImage.strokeWeight(10);
    compassImage.ellipse(300, 300, 400, 400);
    compassImage.noStroke();
    compassImage.fill(255, 55, 0);
    compassImage.triangle(290, 300, 310, 300, 300, 180);
    compassImage.fill(125, 125, 125);
    compassImage.triangle(300, 290, 300, 310, 420, 300);
    compassImage.triangle(290, 300, 310, 300, 300, 420);
    compassImage.triangle(300, 290, 300, 310, 180, 300);
    compassImage.triangle(310, 300, 300, 310, 360, 360);
    compassImage.triangle(290, 300, 240, 360, 300, 310);
    compassImage.triangle(300, 290, 310, 300, 360, 240);
    compassImage.triangle(300, 290, 240, 240, 290, 300);
    compassImage.textSize(20);
    for (var i = 0 ; i < compassCodes.length ; i++) {
        if (i === 0) {
            compassImage.fill(255, 0, 0);
        }
        else {
            compassImage.fill(255, 255, 255);
        }
        if (i % 2 === 0) {
            compassImage.text(compassCodes[i], 300 + cos(i * 45 - 90) * 135, 300 + sin(i * 45 - 90) * 135);
        }
        else {
            compassImage.text(compassCodes[i], 300 + cos(i * 45 - 90) * 105, 300 + sin(i * 45 - 90) * 105);
        }
    }
    compassImage.fill(100, 100, 100, 150);
    compassImage.ellipse(300, 300, 50, 50);
    compassImage.beginShape();
    for (var i = 0 ; i < 60 ; i ++) {
        compassImage.vertex(300 + cos(i - 90) * 25, 300 + sin(i - 90) * 25);
    }
    compassImage.vertex(300 + cos(-60) * 140, 300 + sin(-60) * 140);
    compassImage.endShape();
    compassImage.beginShape();
    for (var i = 180 ; i < 240 ; i += 6) {
        compassImage.vertex(300 + cos(i - 90) * 25, 300 + sin(i - 90) * 25);
    }
    compassImage.vertex(300 + cos(120) * 140, 300 + sin(120) * 140);
    compassImage.endShape();
}*/

var grass = [];

var drawChar = function(id) {
    fill(255, 255, 255);
    strokeWeight(3);
    stroke(0, 0, 0);
    ellipse(125, 540, 60, 60);
    fill(0, 0, 0);
    noStroke();
    if (id !== 5) {
        var mouseang1 = Math.atan2(mouseY - 530, mouseX - 115) * (180 / Math.PI);
        ellipse(115 + cos(mouseang1) * 2.5, 530 + sin(mouseang1) * 2.5, 5, 5);
        var mouseang2 = Math.atan2(mouseY - 530, mouseX - 135) * (180 / Math.PI);
        ellipse(135 + cos(mouseang2) * 2.5, 530 + sin(mouseang2) * 2.5, 5, 5);
    }
    switch (id) {
        case 1:
            pushMatrix();
            translate(125, 540);
            rotate(60);
            translate(-125, -540);
            fill(255, 0, 0);
            arc(125, 542, 50, 50, 80, 100);
            rect(125, 560, 10, 17.5);
            ellipse(125, 550, 20, 15);
            triangle(115, 550, 125, 570, 135, 550);
            popMatrix();
            resetMatrix();
            break;
        case 2:
            stroke(84, 117, 125);
            strokeWeight(3.5);
            point(100, 520);
            point(112, 510);
            point(148, 515);
            
            break;
        case 3:
            pushMatrix();
            translate(125, 540);
            rotate(Math.atan2(mouseY - 540, mouseX - 125) * (180 / Math.PI));
            translate(-125, -540);
            stroke(0, 0, 0);
            strokeWeight(1);
            line(90, 525, 55, 525);
            line(85, 540, 55, 540);
            line(90, 555, 55, 555);
            popMatrix();
            resetMatrix();
            break;
        case 4:
            fill(230, 168, 80);
            var baskx = 125 + cos(225) * 42;
            var basky = 540 + sin(225) * 42;
            ellipse(baskx, basky, 20, 20); 
            stroke(0, 0, 0);
            strokeWeight(1);
            line(baskx, basky - 8, baskx, basky + 8);
            line(baskx - 8, basky, baskx + 8, basky);
            noFill();
            strokeWeight(0.5);
            arc(baskx - 10, basky, 13, 20, -51, 51);
            arc(baskx + 10, basky, 13, 20, 129, 231);
            break;
        case 5:
            var mouseang1 = Math.atan2(mouseY - 535, mouseX - 115) * (180 / Math.PI);
            ellipse(115 + cos(mouseang1) * 2.5, 535 + sin(mouseang1) * 2.5, 5, 5);
            var mouseang2 = Math.atan2(mouseY - 535, mouseX - 135) * (180 / Math.PI);
            ellipse(135 + cos(mouseang2) * 2.5, 535 + sin(mouseang2) * 2.5, 5, 5);
            fill(0, 0, 0);
            rect(125, 519, 40, 8);
            arc(145, 523, 5, 6, 180, 360);
            arc(105, 523, 5, 6, 180, 360);
    }
};

var drawIcon = function(n, x, y, s, t, bcol, rsm) {
    if (rsm) {
        resetMatrix();
    }
    translate(x, y);
    scale(s / 600);
    
    noStroke();
    switch (n) {
        case 1:
            translate(300, 300);
            rotate(45);
            translate(-300, -300);
            fill(140, 72, 52, t);
            beginShape();
            vertex(150, 380);
            vertex(150, 420);
            vertex(280, 420);
            vertex(280, 540);
            vertex(320, 540);
            vertex(320, 420);
            vertex(450, 420);
            vertex(450, 380);
            vertex(150, 380);
            endShape();
            fill(160, 92, 72, t);
            beginShape();
            vertex(280, 380);
            vertex(280, 100);
            vertex(300, 60);
            vertex(320, 100);
            vertex(320, 380);
            vertex(280, 380);
            endShape();
            break;
        case 2:
            translate(300, 300);
            rotate(45);
            translate(-300, -300);
            fill(140, 72, 52, t);
            beginShape();
            vertex(150, 380);
            vertex(150, 420);
            vertex(280, 420);
            vertex(280, 540);
            vertex(320, 540);
            vertex(320, 420);
            vertex(450, 420);
            vertex(450, 380);
            vertex(150, 380);
            endShape();
            fill(138, 134, 133, t);
            beginShape();
            vertex(280, 380);
            vertex(280, 100);
            vertex(300, 60);
            vertex(320, 100);
            vertex(320, 380);
            vertex(280, 380);
            endShape();
            break;
        case 3:
            translate(300, 300);
            rotate(45);
            translate(-300, -300);
            fill(140, 72, 52, t);
            beginShape();
            vertex(150, 380);
            vertex(150, 420);
            vertex(280, 420);
            vertex(280, 540);
            vertex(320, 540);
            vertex(320, 420);
            vertex(450, 420);
            vertex(450, 380);
            vertex(150, 380);
            endShape();
            fill(209, 189, 88, t);
            beginShape();
            vertex(280, 380);
            vertex(280, 100);
            vertex(300, 60);
            vertex(320, 100);
            vertex(320, 380);
            vertex(280, 380);
            endShape();
            break;
        case 4:
            translate(300, 300);
            rotate(45);
            translate(-300, -300);
            fill(140, 72, 52, t);
            beginShape();
            vertex(150, 380);
            vertex(150, 450);
            vertex(190, 450);
            vertex(190, 420);
            vertex(280, 420);
            vertex(280, 540);
            vertex(320, 540);
            vertex(320, 420);
            vertex(410, 420);
            vertex(410, 450);
            vertex(450, 450);
            vertex(450, 420);
            vertex(450, 380);
            vertex(150, 380);
            endShape();
            fill(230, 226, 245, t);
            beginShape();
            vertex(280, 380);
            vertex(280, 150);
            vertex(280.5, 140);
            vertex(281.2, 130);
            vertex(282.3, 120);
            vertex(284, 110);
            vertex(286, 100);
            vertex(288.5, 90);
            vertex(291.5, 80);
            vertex(294.7, 70);
            vertex(300, 60);
            vertex(305.3, 70);
            vertex(308.5, 80);
            vertex(311.5, 90);
            vertex(314, 100);
            vertex(316, 110);
            vertex(317.7, 120);
            vertex(318.8, 130);
            vertex(319.5, 140);
            vertex(320, 150);
            vertex(320, 100);
            vertex(320, 380);
            vertex(280, 380);
            endShape();
            break;
        case 5:
            stroke(255, 255, 255, t);
            strokeWeight(10);
            line(150, 100, 100, 300); 
            line(100, 300, 150, 500);
            stroke(140, 72, 52, t);
            strokeWeight(40);
            noFill();
            arc(150, 300, 700, 400, -90, 90);
            noStroke();
            break;
        case 6:
            stroke(255, 255, 255, t);
            strokeWeight(10);
            line(150, 100, 100, 300); 
            line(100, 300, 150, 500);
            stroke(140, 72, 52, t);
            strokeWeight(40);
            noFill();
            arc(150, 300, 700, 400, -90, 90);
            strokeWeight(8);
            stroke(186, 182, 217, t);
            arc(150, 300, 700, 400, -92.1, 92.1);
            noStroke();
            break;
        case 7:
            stroke(255, 255, 255);
            strokeWeight(10);
            line(150, 100, 100, 300); 
            line(100, 300, 150, 500);
            stroke(140, 72, 52, t);
            strokeWeight(40);
            noFill();
            arc(150, 300, 700, 400, -90, 90);
            strokeWeight(8);
            stroke(168, 151, 64, t);
            arc(150, 300, 700, 400, -92.1, 92.1);
            noStroke();
            break;
        case 8:
            strokeWeight(5);
            translate(300, 300);
            rotate(45);
            translate(-300, -300);
            stroke(140, 72, 52, t);
            line(120, 300, 50, 250);
            line(120, 300, 50, 350);
            line(120, 300, 550, 300);
            line(210, 300, 140, 250);
            line(210, 300, 140, 350);
            fill(204, 210, 224, t);
            noStroke();
            triangle(570, 300, 450, 350, 450, 250);
            break;
        case 9:
            fill(255, 0, 0, t);
            beginShape();
            vertex(150, 250);
            vertex(250, 250);
            vertex(250, 150);
            vertex(350, 150);
            vertex(350, 250);
            vertex(450, 250);
            vertex(450, 350);
            vertex(350, 350);
            vertex(350, 450);
            vertex(250, 450);
            vertex(250, 350);
            vertex(150, 350);
            vertex(150, 250);
            endShape();
            textFont(createFont("monospace"));
            textSize(100);
            text("0-25", 138, 100);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case 10:
            fill(255, 0, 0, t);
            beginShape();
            vertex(150, 250);
            vertex(250, 250);
            vertex(250, 150);
            vertex(350, 150);
            vertex(350, 250);
            vertex(450, 250);
            vertex(450, 350);
            vertex(350, 350);
            vertex(350, 450);
            vertex(250, 450);
            vertex(250, 350);
            vertex(150, 350);
            vertex(150, 250);
            endShape();
            fill(255, 125, 0, t);
            textFont(createFont("monospace"));
            textSize(100);
            text("25-50", 157, 100);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case 11:
            fill(255, 0, 0, t);
            beginShape();
            vertex(150, 250);
            vertex(250, 250);
            vertex(250, 150);
            vertex(350, 150);
            vertex(350, 250);
            vertex(450, 250);
            vertex(450, 350);
            vertex(350, 350);
            vertex(350, 450);
            vertex(250, 450);
            vertex(250, 350);
            vertex(150, 350);
            vertex(150, 250);
            endShape();
            fill(255, 255, 0, t);
            textFont(createFont("monospace"));
            textSize(100);
            text("50-99", 184, 100);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case 12:
            fill(255, 0, 0, t);
            beginShape();
            vertex(150, 250);
            vertex(250, 250);
            vertex(250, 150);
            vertex(350, 150);
            vertex(350, 250);
            vertex(450, 250);
            vertex(450, 350);
            vertex(350, 350);
            vertex(350, 450);
            vertex(250, 450);
            vertex(250, 350);
            vertex(150, 350);
            vertex(150, 250);
            endShape();
            fill(0, 255, 0, t);
            textFont(createFont("monospace"));
            textSize(100);
            text("Full", 184, 100);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case 13:
            fill(255, 0, 0, t);
            beginShape();
            vertex(150, 250);
            vertex(250, 250);
            vertex(250, 150);
            vertex(350, 150);
            vertex(350, 250);
            vertex(450, 250);
            vertex(450, 350);
            vertex(350, 350);
            vertex(350, 450);
            vertex(250, 450);
            vertex(250, 350);
            vertex(150, 350);
            vertex(150, 250);
            endShape();
            fill(255, 255, 255, 250);
            stroke(0, 0, 0, t);
            strokeWeight(5);
            ellipse(450, 150, 250, 250);
            line(450, 150, 450 + cos(frameCount - 90) * 100, 150 + sin(frameCount - 90) * 100);
            line(450, 150, 450 + cos(frameCount / 60 - 90) * 80, 150 + sin(frameCount / 60 - 90) * 80);
            line(450, 150, 450 + cos(frameCount / 720 - 90) * 60, 150 + sin(frameCount / 720 - 90) * 60); 
            for (var i = 0 ; i < 360 ; i += 30) {
                strokeWeight(5);
                line(450 + cos(i) * 123, 150 + sin(i) * 123, 450 + cos(i) * 110, 150 + sin(i) * 110);
                strokeWeight(2);
                for (var j = i + 6 ; j < i + 30 ; j += 6) {
                    line(450 + cos(j) * 125, 150 + sin(j) * 125, 450 + cos(j) * 120, 150 + sin(j) * 120);
                }
            } //A working clock!
            break;
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
            fill(arrColors[n - 14][0], arrColors[n - 14][1], arrColors[n - 14][2], t);
            noStroke();
            rect(300, 300, 200, 100);
            stroke(0, 0, 0, t);
            strokeWeight(2);
            arc(300, 350, 200, 200, 0, 180);
            line(200, 350, 200, 150);
            line(400, 350, 400, 150);
            line(150, 150, 199, 150);
            line(400, 150, 450, 150);
            line(200, 150, 400, 150);
            break;
        case 20:
            image(potionImage, 200, 250);
            noFill();
            noStroke();
            stroke(0, 0, 0, t);
            strokeWeight(2);
            arc(300, 350, 200, 200, 0, 180);
            line(200, 350, 200, 150);
            line(400, 350, 400, 150);
            line(150, 150, 199, 150);
            line(400, 150, 450, 150);
            line(200, 150, 400, 150);
            //fill(bcol[0], bcol[1], bcol[2], 255 - t);
            //rect(300, 300, 600, 600);
            break;
        case 21:
            translate(300, 300);
            rotate(-45);
            translate(-300, -300);
            fill(140, 72, 52, t);
            beginShape();
            vertex(150, 380);
            vertex(150, 500);
            vertex(190, 450);
            vertex(190, 420);
            vertex(280, 420);
            vertex(280, 540);
            vertex(320, 540);
            vertex(320, 420);
            vertex(410, 420);
            vertex(410, 450);
            vertex(450, 500);
            vertex(450, 420);
            vertex(450, 380);
            vertex(150, 380);
            endShape();
            fill(153, 135, 53, t);
            beginShape();
            vertex(280, 380);
            for (var i = 350 ; i > 350 - (34 * 6) ; i -= 34) {
                vertex(280, i);
                vertex(260, i + 20);
                vertex(280, i - 34);
            }
            vertex(280, 150);
            vertex(280.5, 140);
            vertex(281.2, 130);
            vertex(282.3, 120);
            vertex(284, 110);
            vertex(286, 100);
            vertex(288.5, 90);
            vertex(291.5, 80);
            vertex(294.7, 70);
            vertex(300, 60);
            vertex(305.3, 70);
            vertex(308.5, 80);
            vertex(311.5, 90);
            vertex(314, 100);
            vertex(316, 110);
            vertex(317.7, 120);
            vertex(318.8, 130);
            vertex(319.5, 140);
            vertex(320, 150);
            for (var i = 350 - (34 * 5) ; i <= 350 ; i += 34) {
                vertex(318, i - 34);
                vertex(338, i + 20);
                vertex(318, i);
                
                
            }
            vertex(320, 380);
            vertex(280, 380);
            endShape();
            break;
        case 22:
            noStroke();
            fill(0, 0, 0, t);
            rect(300, 350, 50, 300);
            fill(0, 0, 155, t);
            rect(150, 400, 60, 60, 20);
            fill(0, 0, 0, t);
            ellipse(140, 390, 5, 5);
            ellipse(160, 390, 5, 5);
            stroke(0, 0, 0, t);
            strokeWeight(5);
            line(200, 400, 450, 400);
            line(400, 350, 450, 400);
            line(400, 450, 450, 400);
            break;
        /*case 23:
        case 24:
        case 25:
            fill(55, 55, 55);
            stroke(0, 0, 0);
            strokeWeight(10);
            ellipse(300, 300, 400, 400);
            stroke(255, 255, 255);
            strokeWeight(3);
            
            noFill();
            stroke(0, 0, 0);
            strokeWeight(10);
            ellipse(300, 300, 400, 400);
            noStroke();
            fill(255, 55, 0);
            triangle(290, 300, 310, 300, 300, 180);
            fill(125, 125, 125);
            triangle(300, 290, 300, 310, 420, 300);
            triangle(290, 300, 310, 300, 300, 420);
            triangle(300, 290, 300, 310, 180, 300);
            triangle(310, 300, 300, 310, 360, 360);
            triangle(290, 300, 240, 360, 300, 310);
            triangle(300, 290, 310, 300, 360, 240);
            triangle(300, 290, 240, 240, 290, 300);
            textSize(20);
            for (var i = 0 ; i < compassCodes.length ; i++) {
                if (i === 0) {
                    fill(255, 0, 0);
                }
                else {
                    fill(255, 255, 255);
                }
                if (i % 2 === 0) {
                    text(compassCodes[i], 300 + cos(i * 45 - 90) * 135, 300 + sin(i * 45 - 90) * 135);
                }
                else {
                    text(compassCodes[i], 300 + cos(i * 45 - 90) * 105, 300 + sin(i * 45 - 90) * 105);
                }
            }
            fill(100, 100, 100, 150);
            ellipse(300, 300, 50, 50);
            beginShape();
            vertex(300 + cos(0 - 90) * 25, 300 + sin(0 - 90) * 25);
            vertex(300 + cos(60 - 90) * 25, 300 + sin(60 - 90) * 25);
            vertex(300 + cos(-60) * 140, 300 + sin(-60) * 140);
            endShape();
            beginShape();
            vertex(300 + cos(90) * 25, 300 + sin(90) * 25);
            vertex(300 + cos(150) * 25, 300 + sin(150) * 25);
            vertex(300 + cos(-60) * 140, 300 + sin(-60) * 140);
            endShape();
            ////break;
            if (n === 23) {
                fill(96, 194, 209);
                triangle(315, 90, 360, 60, 450, 240);
                fill(100, 198, 213);
                triangle(360, 60, 420, 60, 450, 240);
                fill(104, 202, 217);
                triangle(420, 60, 480, 60, 450, 240);
                fill(108, 206, 221);
                triangle(480, 60, 540, 60, 450, 240);
                fill(112, 210, 225);
                triangle(540, 60, 585, 90, 450, 240);
            }
            if (n === 24) {
                fill(224, 52, 52);
                beginShape();
                vertex(405, 160);
                vertex(400, 200);
                vertex(440, 195);
                vertex(495, 140);
                vertex(500, 100);
                vertex(460, 105);
                endShape();
                fill(244, 112, 112);
                quad(405, 160, 404, 168, 468, 104, 460, 105);
                fill(234, 82, 82);
                quad(404, 168, 403, 176, 476, 103, 468, 104);
            }
            if (n === 25) {
                fill(22, 168, 66);
                beginShape();
                vertex(410, 230);
                vertex(490, 230);
                vertex(520, 200);
                vertex(520, 100);
                vertex(490, 70);
                vertex(410, 70);
                vertex(380, 100);
                vertex(380, 200);
                vertex(410, 230);
                endShape();
                fill(55, 198, 96);
                beginShape();
                vertex(420, 200);
                vertex(480, 200);
                vertex(490, 190);
                vertex(490, 110);
                vertex(480, 100);
                vertex(420, 100);
                vertex(410, 110);
                vertex(410, 190);
                vertex(420, 200);
                endShape();
            }
            break;*/
        case 23:
            fill(0, 0, 0);
            noStroke();
            beginShape();
            vertex(350, 500);
            vertex(500, 450);
            vertex(300, 200);
            vertex(250, 180);
            vertex(150, 200);
            vertex(100, 300);
            vertex(160, 280);
            vertex(290, 340);
            endShape();
            break;
        case 24:
            fill(19, 74, 45);
            noStroke();
            beginShape();
            vertex(350, 500);
            vertex(500, 450);
            vertex(300, 200);
            vertex(250, 180);
            vertex(150, 200);
            vertex(100, 300);
            vertex(160, 280);
            vertex(290, 340);
            endShape();
            break;
        case 25:
            fill(79, 7, 48);
            noStroke();
            beginShape();
            vertex(350, 500);
            vertex(500, 450);
            vertex(300, 200);
            vertex(250, 180);
            vertex(150, 200);
            vertex(100, 300);
            vertex(160, 280);
            vertex(290, 340);
            endShape();
            break;
        case 26:
            translate(300, 300);
            rotate(8);
            translate(-300, -300);
            stroke(0, 0, 0, t);
            strokeWeight(3);
            noFill();
            beginShape();
            vertex(240, 500);
            vertex(360, 500);
            vertex(360, 300);
            vertex(358, 260);
            vertex(354, 220);
            vertex(342, 180);
            vertex(328, 140);
            vertex(310, 100);
            vertex(290, 100);
            vertex(272, 140);
            vertex(258, 180);
            vertex(246, 220);
            vertex(242, 260);
            vertex(240, 300);
            vertex(240, 500);
            vertex(240, 500);
            endShape();
            break;
        case 27:
            translate(300, 300);
            rotate(-8);
            translate(-300, -300);
            stroke(0, 0, 0, t);
            strokeWeight(3);
            noFill();
            beginShape();
            vertex(240, 500);
            vertex(360, 500);
            vertex(360, 300);
            vertex(358, 260);
            vertex(354, 220);
            vertex(342, 180);
            vertex(328, 140);
            vertex(310, 100);
            vertex(290, 100);
            vertex(272, 140);
            vertex(258, 180);
            vertex(246, 220);
            vertex(242, 260);
            vertex(240, 300);
            vertex(240, 500);
            vertex(240, 500);
            endShape();
            noStroke();
            fill(0, 0, 255, t);
            beginShape();
            vertex(240, 500);
            vertex(360, 500);
            vertex(360, 300);
            vertex(358, 260);
            vertex(354, 220);
            vertex(342, 180);
            vertex(328, 140);
            vertex(272, 140);
            vertex(258, 180);
            vertex(246, 220);
            vertex(242, 260);
            vertex(240, 300);
            vertex(240, 500);
            vertex(240, 500);
            endShape();
            break;
        case 28:
            fill(74, 45, 12, t);
            rect(300, 400, 150, 150);
            quad(310, 190, 410, 200, 400, 290, 300, 280);
            quad(100, 200, 200, 100, 300, 200, 200, 300);
            break;
        case 29:
            fill(0, 0, 0, t);
            for (var i = 100 ; i < 500 ; i += 55) {
                wdt = (510 - i) / 3;
                for (var j = 300 - wdt ; j <= 300 + wdt ; j += (wdt * 2) / 4.1) {
                    ellipse(j, i, 50, 50);
                }
            }
            break;
        case 30:
            fill(255, 0, 55, t);
            for (var i = 100 ; i < 500 ; i += 55) {
                wdt = (510 - i) / 3;
                for (var j = 300 - wdt ; j <= 300 + wdt ; j += (wdt * 2) / 4.1) {
                    ellipse(j, i, 50, 50);
                }
            }
    }
};

var arrows = [];

var Arrow = function(x, y, ang, f, d) {
    this.x = x;
    this.y = y;
    this.fired = f;
    this.damage = d;
    this.orgx = x;
    this.orgy = y;
    this.ang = ang;
    this.dead = false;
    this.dx = cos(-this.ang - 90) * 12;
    this.dy = sin(-this.ang - 90) * 12;
};

Arrow.prototype.update = function() {
    this.x += this.dx;
    this.y += this.dy;
    if (dist(this.x, this.y, this.orgx, this.orgy) > 300) {
        this.dead = true;
    }
    if (!this.dead) {
        translate(this.x, this.y);
        rotate(-this.ang - 90 - 45);
        translate(-this.x, -this.y);
        drawIcon(8, this.x, this.y, 30);
        resetMatrix();
        //translate(300 - Player1.x, 300 
    }
    /*for (var i = 0 ; i < players.length ; i++) {
        if (i === this.fired) {
            continue;
        }
        if (dist(this.x + cos(-this.ang - 90) * 11, this.y + sin(-this.ang - 90) * 11, players[i].x, players[i].y) < 30) {
            players[i].health -= this.damage;
            if (players[i].health <= 0) {
                players[i].killInd = this.fired;
                players[this.fired].kills ++;
            }
            players[i].forceframe = 5;
            players[i].dx = this.dx * 2;
            players[i].dy = this.dy * 2;
            players[i].takingDamage = true;
            players[i].takingDamageFrame = true;
            this.dead = true;
        }
    }*/
    if (this.dead) {
        arrows.splice(arrows.indexOf(this), 1);
    }
};

var lakes;

var boats = [];

var Boat = function(x, y, ang) {
    this.x = x;
    this.y = y;
    this.ang = -ang - 90;
    this.moveSpeed = 0;
};

Boat.prototype.draww = function() {
    pushMatrix();
    translate(this.x, this.y);
    rotate(-this.ang - 90);
    translate(-this.x, -this.y);
    fill(207, 177, 118);
    stroke(157, 127, 58);
    strokeWeight(1);
    rect(this.x, this.y, 60, 30);
    arc(this.x - 30, this.y + 15, 80, 60, 210, 270);
    arc(this.x + 30, this.y + 15, 80, 60, 270, 330);
    arc(this.x - 30, this.y - 15, 80, 60, 90, 150);
    arc(this.x + 30, this.y - 15, 80, 60, 30, 90);
    fill(157, 127, 58);
    popMatrix();
};

Boat.prototype.update = function() {
    this.prevx = this.x;
    this.prevy = this.y;
    this.x += cos(-this.ang - 90) * this.moveSpeed;
    this.y += sin(-this.ang - 90) * this.moveSpeed;
    this.inLake = false;
    for (var i = 0 ; i < lakes.length ; i++) {
        if (dist(this.x, this.y, lakes[i][0], lakes[i][1]) < lakes[i][2] / 2 + 30 && (!lakes[i][3] || dist(this.x, this.y, lakes[i][0], lakes[i][1]) > lakes[i][3] / 2 + 30)) {
            this.inLake = true;
        }
    }
    if (!this.inLake) {
        this.x = this.prevx;
        this.y = this.prevy;
    }
};

Boat.prototype.display = function() {
    this.draww();
    this.update();
};

var chests = [];
var droppedItems = [];

var colorZones;

var lakes;

var beaches;

var realms;
var mapSeed;

var validPoint = function(x, y) {
    var validtr = false;
    for (var i = 0 ; i < realms.length ; i++) {
        if (realms[i][0] === "Plains" && x > realms[i][1] && y > realms[i][2] && x < realms[i][1] + realms[i][3] && y < realms[i][2] + realms[i][4]) {
            validtr = true;
        }
    }
    for (var k = 0 ; k < paths.length ; k++) {
        if (paths[k][0] === "Ellipse") {
            if (dist(x, y, paths[k][1], paths[k][2]) < paths[k][3] + 50) {
                validtr = true;
            }
        }
        if (paths[k][0] === "Arc") {
            if (dist(x, y, paths[k][1], paths[k][2]) > paths[k][3] && dist(x, y, paths[k][1], paths[k][2]) < paths[k][4]) {
                if (!paths[k][7] || dist(x, y, paths[k][5], paths[k][6]) <= paths[k][7]) {
                    validtr = true;
                }
            }
        }
        if (paths[k][0] === "Line") {
            if (dist(x, y, paths[k][1], paths[k][2]) > paths[k][3] && dist(x, y, paths[k][1], paths[k][2]) < paths[k][4] && x > paths[k][5] && y > paths[k][6] && x < paths[k][7] && y < paths[k][8]) {
                validtr = true;
            }
        }
    }
    return validtr;
};

var mapNames;

var targetIncr = [100, 50, 100];

var Player = function() {
    this.totalKills = tk;
    this.x = 300;
    this.y = 300;
    this.hunger = 100;
    this.speedF = 6;
    this.incr = inp;
    this.name = "You";
    this.kills = 0;
    this.thirst = 100;
    this.ang = 0;
    this.dist = 0;
    this.surtime = 0;
    this.colorTime = 0;
    this.color = 0;
    this.ang = 0;
    this.forceframe = 0;
    this.lastEmptySpace = 0;
    this.cpuControlled = false;
    this.rad = 15;
    this.dx = 0;
    this.dy = 0;
    this.inventory = [];
    this.poisoned = false;
    this.firstArrow = 0;
    this.arrowcount = [];
    this.healthCount = [];
    this.polyjuiceCount = [];
    this.minPlayerInd = 0;
    this.minPlayerDist = 0;
    this.arrow = true;
    for (var i = 0 ; i < 27 ; i++) {
       this.inventory.push("Empty Space");
       this.arrowcount.push(0);
       this.healthCount.push(0);
       this.polyjuiceCount.push(0);
    }
    this.weapon = "";
    this.weaponInd = "No Weapon";
    this.takingDamage = false;
    this.takingDamageFrame = 0;
    this.health = 100;
    this.arrow = false;
    this.prevsec = second();
    this.gone = false;
    this.strColorTime = "";
    this.polyColor = false;
    this.nearPlayerDir = 0;
    this.stunned = false;
    this.inBoat = false;
    this.attacking = false;
    this.attackCooldown = 0;
    this.attackPos = 0;
    this.strength = stats[0];
    this.speed = stats[1];
    this.stamina = stats[2];
    this.matchStamina = 100;
};

Player.prototype.draww = function() {
    if (this.takingDamageFrame) {
        fill(255, 0, 0, this.takingDamageFrame * (255 / 5));
        noStroke();
        ellipse(this.x, this.y, 30, 30);
        noFill();
        strokeWeight(3);
        stroke(0, 0, 0);
        ellipse(this.x, this.y, 30, 30);
    }
    else {
        fill(colors[this.color - 1]);
        if (this.cpuControlled) {
            if (this.strategy[1] === 2) {
                fill(255, 0, 0);
            }
            if (this.strategy[1] === 1) {
                fill(0, 255, 0);
            }
            if (this.strategy[1] === 0) {
                fill(0, 0, 255);
            }
        }
        strokeWeight(3);
        stroke(212, 166, 81);
        fill(222, 181, 126);
        ellipse(this.x, this.y, 30, 30);
        noStroke();
        if (!this.cpuControlled) {
            this.ap = 20 + this.attackPos;
        }
        else {
            this.ap = 20;
        }
        if (!this.cpuControlled) {
            ellipse(this.x + this.ap * cos(-90 - this.ang + 40), this.y + this.ap * sin(-90 - this.ang + 40), 8, 8);
            ellipse(this.x + 20 * cos(-90 - this.ang - 40), this.y + 20 * sin(-90 - this.ang - 40), 8, 8);
        }
        else {
            ellipse(this.x + this.ap * cos(this.ang + 220), this.y + this.ap * sin(this.ang + 220), 8, 8);
            ellipse(this.x + 20 * cos(this.ang + 140), this.y + 20 * sin(this.ang + 140), 8, 8);
        }
        fill(0, 0, 0);
        //ellipse(this.x, this.y, 30, 30);
    }
    if (this.cpuControlled) {
        //if (!this.inGrass) {
            fill(0, 0, 0, 50);
            noStroke();
            rect(this.x, this.y - 24, this.name.length * 6.3, 10, 12);
            fill(255, 255, 255);
            textFont(createFont("monospace"));
            textSize(10);
            text(this.name, this.x, this.y - 24);
            textFont(createFont("Avenir"));
            fill(255, 0, 0);
            textSize(20);
            //text(this.health, this.x, this.y - 36);
            textFont(createFont("AvenirNext-UltraLight"));
        //}
        //stroke(0, 0, 0);
        //strokeWeight(10);
        //line(this.x, this.y, this.target[0], this.target[1]);
    }
    if (!this.cpuControlled) {
        this.item = itemList.indexOf(this.weapon);
        translate(cos(-this.ang - 90) * this.attackPos, sin(-this.ang - 90) * this.attackPos);
        translate(this.x, this.y);
        rotate(-this.ang + 40);
        translate(-this.x, -this.y);
        if (this.item <= 4) {
            translate(this.x - 5, this.y - 27);
            rotate(-45);
            translate(-this.x + 5, -this.y + 27);
        }
        if (this.item === 21) {
            translate(this.x - 5, this.y - 27);
            rotate(45);
            translate(-this.x + 5, -this.y + 27);
        }
        if (this.weaponIcon >= 4 && this.weaponIcon <= 6 && this.arrow) {
            
            stroke(125, 125, 125);
            strokeWeight(10);
            for (var i = this.y - 40; i > this.y - 300 ; i -= 30) {
                point(this.x, i);
            }
            noStroke();
        }
        
        drawIcon(this.item, this.x - 10, this.y - 36, 20, 255);
        resetMatrix();
        translate(300 - this.x, 300 - this.y);
        popMatrix();
        resetMatrix();
        //if (!this.cpuControlled) {
            
            
            /*if ((this.weaponIcon === 23 && this.nearChestDir !== "No Chest") || this.weaponIcon === 24 || this.weaponIcon === 25) {
                translate(300, 300);
                if (this.weaponIcon === 23) {
                    rotate(this.nearChestDir - 90 + this.ang);
                }
                if (this.weaponIcon === 25) {
                    rotate(this.nearPlayerDir - 90 + this.ang);
                }
                translate(-300, -300);
                stroke(0, 0, 0, 100);
                strokeWeight(5);
                line(300, 500, 300, 100);
                line(200, 200, 300, 100);
                line(400, 200, 300, 100);
            }
            if (this.weaponIcon === 23 && this.nearChestDir === "No Chest") {
                
                fill(0, 0, 0, 55);
                textSize(60);
                text("No Valid Chest", 300, 240);
            }*/
        //}
    }
    else {
        this.item = itemList.indexOf(this.weapon);
        translate(this.x, this.y);
        rotate(this.ang + 120);
        translate(-this.x, -this.y);
        drawIcon(this.item, this.x - 10, this.y - 36, 20, 255);
        if (this.item <= 4) {
            translate(this.x - 5, this.y - 27);
            rotate(45);
            translate(-this.x + 5, -this.y + 27);
        }
        if (this.item === 21) {
            translate(this.x - 5, this.y - 27);
            rotate(-45);
            translate(-this.x + 5, -this.y + 27);
        }
        resetMatrix();
        translate(300, 0);
        scale(sf);
        translate(-300, 0);
        //scale(0.1);
        translate(300, 300);
        rotate(Player1.ang);
        translate(-300, -300);
        translate(300 - Player1.x, 300 - Player1.y);
    }
};

Player.prototype.update = function() {
    if (this.matchStamina <= 0) {
        this.matchStamina = 0;
    }
    if ((this.x > -20000) === false || (this.y > -20000) === false) {
        //println("A positioning error has occurred on the map " + mapNames[mapSeed - 1] + ". Please report this in the Tips & Thanks:" + " " + this.x + " " + this.y);
        if (this.prevx > -20000) {
            this.x = this.prevx;
        }
        else {
            this.x = 300;
        }
        if (this.prevy > -20000) {
            this.y = this.prevy;
        }
        else {
            this.y = 300;
        }
    }
    this.health = Math.floor(this.health);
    if ((this.health > 0) === false && (this.health < 100) === false) {
        //println("A health error has occurred on the map " + mapNames[mapSeed - 1] + ". Please report this in the Tips & Thanks: " + " " + this.health);
        this.health = 10;
    }
    inp = this.incr;
    tk = this.totalKills;
    if (this.poisoned) {
        this.health --;
        if (this.health <= 0) {
            this.killInd = "Poison";
            this.die();
        }
    }
    this.staminaF = this.stamina * 0.01;
    this.speedF = (6 + (this.speed - 4) / 3) * (((this.matchStamina + 25) * 0.8) / 75);
    this.strengthF = Math.floor(3 + (this.strength - 4) / 3);
    this.defenseStrengthF = (-1 / 30) * this.strength + (34 / 30);
    this.matchStamina -= Math.max(Math.min(0.01 * ((13 - this.stamina) / 4), 0.3), 0.003);
    this.hunger -= 0.003 * (this.matchStamina / 75);
    this.thirst -= 0.01 * (this.matchStamina / 75);
    if (!this.cpuControlled) {
        this.gotBottle = false;
        this.bottle = false;
        if (this.weaponIcon === 26) {
            this.gotBottle = true;
            this.bottleInd = this.weaponInd;
            //this.weapon = "No Weapon";
            //this.weaponInd = "No Weapon";
        }
        for (var i = 0 ; i < this.inventory.length ; i++) {
            if (itemList.indexOf(this.inventory[i]) === 26) {
                this.bottle = true;
            }
        }
        //for (var i = 0 ; i < this
    }
    if (this.hunger < 10) {
        this.health -= 5;
        if (this.health <= 0) {
            this.die();
            this.killInd = "Hunger";
        }
    }
    if (this.hunger < 0) {
        this.die();
        this.killInd = "Hunger";
    }
    if (this.thirst < 10) {
        this.health -= 5;
        if (this.health <= 0) {
            this.die();
            this.killInd = "Thirst";
        }
    }
    if (this.thirst < 0) {
        this.die();
        this.killInd = "Thirst";
    }
    if (this.thirst > 100) {
        this.thirst = 100;
        this.hunger += 3;
    }
    if (this.hunger > 100) {
        this.hunger = 100;
        this.health += 1;
    }
    if (this.matchStamina > 100) {
        this.matchStamina = 100;
    }
    this.surprevx = this.x;
    this.surprevy = this.y;
    if (!this.cpuControlled) {
        this.treeprevx = this.x;
        this.treeprevy = this.y;
    }
    if (this.attackFrame === 1) {
        this.attackPos += 5;
        if (this.attackPos > 9) {
            this.attackFrame = 2;
        }
    }
    if (this.attackFrame === 2) {
        this.attackPos -= 2;
        if (this.attackPos < 1) {
            this.attackFrame = 0;
        }
    }
    
    if (this.attacking) {
        this.attacking = false;
        switch (this.weaponIcon) {
            case 3:
                this.attackCooldown = 5;
                break;
            case 2:
                this.attackCooldown = 8;
                break;
            case 21:
                this.attackCooldown = 9;
                break;
            case 1:
                this.attackCooldown = 12;
                break;
            case 0:
                this.attackCooldown = 16;
                break;
            default:
                this.attackCooldown = 10;
                break;
        }
    }
    this.attackCooldown --;
    if (keys[32] && !this.cpuControlled && this.attackCooldown <= 0 && spacepressed) {
        this.attacking = true;
        this.attackFrame = 1;
    }
    if (this.cpuControlled && this.attackCooldown <= 0 && random(0, 3) < 1) {
        this.attacking = true;
    }
    this.inGrass = false;
    for (var i = 0 ; i < grass.length ; i++) {
        if (dist(this.x, this.y, grass[i][0], grass[i][1]) < (grass[i][2] + 30) / 2) {
            this.inGrass = true;
        }
    }
    this.x += this.dx;
    this.y += this.dy;
    
    this.cooldown -= 1;
    if (this.cooldown <= 0) {
        this.cooldown = 0;
        this.dx *= 0.6;
        this.dy *= 0.6;
    }
    this.bodyOfWater = false;
    //this.thirst -= 0.004;
    if (this.colorTime <= 0 && !this.polyColor) {
        this.color = 0;
    }
    this.comp = [false, false, false];
    for (var i = 0 ; i < this.inventory.length ; i++) {
        if (this.inventory[i] === "Sharktooth Fang") {
            this.comp[0] = true;
        }
        if (this.inventory[i] === "Snakeskin Fang") {
            this.comp[1] = true;
        }
        if (this.inventory[i] === "Bearjaw Fang") {
            this.comp[2] = true;
        }
    }
    this.compCount = 0;
    for (var i = 0 ; i < this.comp.length ; i++) {
        if (this.comp[i]) {
            this.compCount ++;
        }
    }
    if (this.compCount < 3 && this.compCount > 0 && random(0, 1) < 0.02) {
        this.health --;
        if (this.health <= 0) {
            this.killInd = "Fang";
            this.die();
        }
    }
    if (this.compCount === 3) {
        if (random(0, 1) < 0.07) {
            this.health ++;
        }
        this.strengthF = 12;
    }
    if (this.comp[0] && this.comp[1] && this.comp[2] && !this.cpuControlled) {
        mythicalPowers = true;
    }
    if (this.gone) {
        if (Math.floor(second()) - Math.floor(this.prevsec) >= 0) {
            this.colorTime -= Math.floor(second()) - Math.floor(this.prevsec);
            this.surtime += Math.floor(second()) - Math.floor(this.prevsec);
            for (var i = 0 ; i < this.healthCount.length ; i++) {
                this.healthCount[i] -= Math.floor(second()) - Math.floor(this.prevsec);
                this.polyjuiceCount[i] -= Math.floor(second()) - Math.floor(this.prevsec);
            }
            if (!this.cpuControlled) {
                countdown -= Math.floor(second()) - Math.floor(this.prevsec);
            }
        }
        else {
            this.colorTime -= (60 + (Math.floor(second()) - Math.floor(this.prevsec)));
            this.sur += (60 + (Math.floor(second()) - Math.floor(this.prevsec)));
            if (!this.cpuControlled) {
                countdown -= (60 + (Math.floor(second()) - Math.floor(this.prevsec)));
            }
            for (var i = 0 ; i < this.healthCount.length ; i++) {
               this.healthCount[i] -= (60 + (Math.floor(second()) - Math.floor(this.prevsec)));
                this.polyjuiceCount[i] -= (60 + (Math.floor(second()) - Math.floor(this.prevsec)));
            }
        }
        
    }
    if (this.color !== 0 && !this.polyColor) {
        this.mod = (this.colorTime % 60).toString().split("");
        if (this.mod.length < 2) {
            this.mod.splice(0, 0, "0");
        }
        this.mod = this.mod.join("");
        this.strColorTime = Math.floor(this.colorTime / 60).toString() + ":" + this.mod;
    }
    else {
        this.strColorTime = "";
    }
    this.gone = true;
    if (!this.cpuControlled) {
        this.weaponIcon = itemList.indexOf(this.inventory[this.weaponInd]);
    }
    var l = 0;
    this.found = false;
    while (l < this.inventory.length && !this.found) {
        if (this.inventory[l] === "Sheath of Arrows") {
            this.found = true;
            this.firstArrow = l;
        }
        l++;
    }
    if (l === this.inventory.length) {
        this.firstArrow = "No Arrow";
    }
    if (this.takingDamageFrame > 0) {
        this.takingDamageFrame --;
    }
    this.forceframe --;
    if ((keys[RIGHT] || keys[68]) && !this.cpuControlled && !displayed && !this.inBoat) {
        
        if (!this.inBeach) {
            ang -= (this.speedF / 2);
        }
        else {
            ang -= (this.speedF / 3);
        }
    }
    if ((keys[LEFT] || keys[65]) && !this.cpuControlled && !displayed && !this.inBoat) {
        if (!this.inBeach) {
            ang += (this.speedF / 2);
        }
        else {
            ang += (this.speedF / 3);
        }
        
    }
    if (!this.cpuControlled) {
        this.ang = ang;
    }
    this.collided = false;
    
    this.dir = new PVector(this.x, this.y);
    this.pxvector = new PVector(this.prevx, this.prevy);
    this.dir.sub(this.pxvector);
    
    if (!this.cpuControlled && !displayed && (keys[UP] || keys[87]) && countdown <= 0 && !paused) {
        //this.ang = Math.atan((mouseY - (300 - this.y) - this.y) / (mouseX - (300 - this.x) - this.x)) * (180 / Math.PI);
        /*if (mouseX - (300 - this.x) < this.x) {
            this.ang += 180;
        }
        while (this.ang < 0) {
            this.ang += 360;
        }*/
        if (this.forceframe <= 0) {
            if (!this.inBeach && validPoint(this.x, this.y)) {
                this.x += cos(-this.ang - 90) * this.speedF;
                this.y += sin(-this.ang - 90) * this.speedF;
            }
            else if (this.inBeach) {
                this.x += cos(-this.ang - 90) * (this.speedF * (2 / 3));
                this.y += sin(-this.ang - 90) * (this.speedF * (2 / 3));
            }
            else {
                this.x += cos(-this.ang - 90) * (this.speedF / 2);
                this.y += sin(-this.ang - 90) * (this.speedF / 2);
            }
        }
    }
    if ((keys[DOWN] || keys[83]) && !this.cpuControlled && countdown <= 0 && !paused && !displayed) {
        this.x -= cos(-this.ang - 90) * (this.speedF / 3);
        this.y -= sin(-this.ang - 90) * (this.speedF / 3);
    }
    if (this.prevx !== this.x || this.prevy !== this.y) {
        this.moving = true;
    }
    else {
        this.moving = false;
    }
    if (this.forceframe > 0) {
        //this.x += this.dx;
        //this.y += this.dy;
        this.dx *= 0.8;
        this.dy *= 0.8;
    }
    this.minPlayerDist = 1000 * 100000000;
    this.minPlayerInd = 0;
    for (var i = 0 ; i < players.length ; i++) {
        if (dist(this.x, this.y, players[i].x, players[i].y) < this.minPlayerDist && players[i] !== this) {
            this.minPlayerDist = dist(this.x, this.y, players[i].x, players[i].y);
            this.minPlayerInd = i;
        }
        /*if (Collide(this, players[i]) && players[i] !== this) {
            
            this.y = this.prevy;
        }*/
        if (Collide(this, players[i]) && players[i] !== this) {
                if (dist(this.x, this.y, players[i].x, players[i].y) < 25) {
                    this.x = this.prevx;
                    this.y = this.prevy;
                }
                //players[i].dx = this.dir.x * 7;
                //players[i].dy = this.dir.y * 7;
                //players[i].forceframe = 5;
                //players[i].x = players[i].prevx;
                //players[i].y = players[i].prevy;
                if (this.attacking) {
                    players[i].cooldown = players[i].cooldownFactor;
                    this.cooldown = this.hitCooldownFactor;
                    if (this.weaponInd === "No Weapon" || (this.weaponIcon >= 5 && this.weaponIcon !== 21)) {
                        players[i].immediatelyGoing = false;
                        if (Math.max(2, this.strengthF) > 0) {
                            players[i].health -= Math.max(2, this.strengthF);
                        }
                        else {
                            players[i].health -= 2;
                        }
                        if (players[i].health <= 0) {
                            players[i].killInd = players.indexOf(this);
                            players[i].die();
                            
                            this.kills ++;
                            if (!this.cpuControlled) {
                                savage++;
                            }
                        }
                        players[i].takingDamage = true;
                        players[i].takingDamageFrame = 5;
                    }
                    else if (this.weaponIcon >= 0 && this.weaponIcon <= 4) {
                        if (Math.min(Math.max(6, (this.weaponIcon * (this.strengthF * 4) + 6) * players[i].defenseStrengthF), 48) > 0) {
                            players[i].health -= Math.min(Math.max(6, (this.weaponIcon * (this.strengthF * 4) + 6) * players[i].defenseStrengthF), 48);
                        }
                        else {
                            players[i].health -= 5;
                        }
                        if (players[i].health <= 0) {
                            players[i].killInd = players.indexOf(this);
                            players[i].die();
                            
                            this.kills ++;
                            if (!this.cpuControlled) {
                                savage++;
                            }
                        }
                        players[i].takingDamage = true;
                        players[i].takingDamageFrame = 5;
                    }
                    else if (this.weaponIcon === 21) {
                        if (Math.max((70 + (this.strengthF * 2)) * players[i].defenseStrengthF, 50) > 0) {
                            players[i].health -= Math.max((70 + (this.strengthF * 2)) * players[i].defenseStrengthF, 50);
                        }
                        else {
                            players[i].health -= 50;
                        }
                        if (players[i].health <= 0) {
                            players[i].killInd = players.indexOf(this);
                            players[i].die();
                            
                            this.kills ++;
                            if (!this.cpuControlled) {
                                savage++;
                                dragonsPowers = true;
                            }
                        }
                        players[i].onFire = true;
                        players[i].takingDamage = true;
                        players[i].takingDamageFrame = 5;
                    }
                }
            /*if (this.moving && players[i].moving) {
                /*this.dx = -this.dir.x * 5;
                this.dy = -this.dir.y * 5;
                players[i].dx = this.dir.x * 5;
                players[i].dy = this.dir.y * 5;*
                this.forceframe = 5;
                players[i].forceframe = 5;
                if (this.weaponIcon >= 1 && this.weaponIcon <= 4) {
                    players[i].health -= this.weaponIcon * 6;
                    players[i].takingDamage = true;
                    players[i].takingDamageFrame = 5;
                }
                else if (this.weaponIcon === 20) {
                    players[i].health -= 36;
                    players[i].onFire = true;
                    players[i].takingDamage = true;
                    players[i].takingDamageFrame = 5;
                }
            }*/
            /*if (this.moving && players[i].moving) {
                this.x -= this.dir.x * 10;
                players[i].x -= players[i].dir.x * 10;
                this.y -= this.dir.y * 10;
                players[i].y -= players[i].dir.y * 10;
                this.collided = true;
                players[i].collided = true;
            }
            else if (this.moving && !players[i].moving) {
                this.x -= this.dir.x * 2;
                players[i].x += this.dir.x * 10;
                this.y -= this.dir.x * 2;
                players[i].y += this.dir.y * 10;
                this.collided = true;
                players[i].collided = true;
            }
            else if (players[i].moving && !this.moving) {
                this.x += players[i].dir.x * 10;
                players[i].x -= players[i].dir.x * 2;
                this.y += players[i].dir.y * 10;
                players[i].y -= players[i].dir.y * 2;
                this.collided = true;
                players[i].collided = true;
            }*/
        }
    }
    /*if (this.weaponIcon >= 4 && this.weaponIcon <= 6 && this.arrow && spaceClicked) {
        //arrows.push(new Arrow(this.x, this.y, this.ang, players.indexOf(this), 21 + (this.weaponIcon - 4) * 6));
        this.arrowcount[this.firstArrow] --;
    }*/
    if (this.firstArrow !== "No Arrow") {
        if (this.arrowcount[this.firstArrow] <= 0) {
            this.inventory[this.firstArrow] = "Empty Space";
            this.arrow = false;
        }
    }
    this.nearPlayerDir = CalculateAngle(this.x, players[this.minPlayerInd].x, this.y, players[this.minPlayerInd].y);
    this.minChestInd = "No Chest";
    this.minChestDist = 1000 * 100000000;
    if (!this.cpuControlled) {
        for (var i = 0 ; i < chests.length ; i++) {
            if (chests[i].mythical && dist(chests[i].x, chests[i].y, this.x, this.y) < this.minChestDist) {
                this.minChestDist = dist(chests[i].x, chests[i].y, this.x, this.y);
                this.minChestInd = i;
            }
        }
    }
    if (this.minChestInd !== "No Chest") {
        this.nearChestDir = CalculateAngle(this.x + 0.001, chests[this.minChestInd].x, this.y, chests[this.minChestInd].y);
    }
    else {
        this.nearChestDir = "No Chest";
    }
    if (dist(this.x, this.y, 300, 300) > Math.max(borderDist / 2, 600)) {
        this.health --;
        if (this.health <= 0) {
            this.killInd = "Border";
            this.die();
        }
    }
    this.colorsOn = [];
    for (var i = 0 ; i < colorZones.length ; i++) {
        if (dist(this.x, this.y, colorZones[i][0], colorZones[i][1]) < colorZones[i][2] / 2) {
            this.colorsOn.push(colorZones[i][3]);
        }
    }
    this.allowed = false;
    if (this.colorsOn.length === 0) {
        this.allowed = true;
    }
    for (var i = 0 ; i < this.colorsOn.length ; i++) {
        if (this.colorsOn[i] + 1 === this.color) {
            this.allowed = true;
        }
    }
    if (this.allowed && this.colorsOn.length > 0 && !this.cpuControlled) {
        coloring = true;
    }
    if (!this.allowed) {
        if (this.cpuControlled) {
            this.colColor = true;
            this.colColorVal = this.colorsOn[0] + 1;
        }
        this.oldx = this.x;
        this.oldy = this.y;
        this.x = this.prevx;
        this.y = this.prevy;
        fill(0, 0, 0);
        textFont(createFont("Avenir"));
        var cStr = "";
        for (var i = 0 ; i < this.colorsOn.length ; i++) {
            cStr += colorWords[this.colorsOn[i] + 1];
            if (i < this.colorsOn.length - 2) {
                cStr += ", ";
            }
            else if (i < this.colorsOn.length - 1) {
                cStr += ", or ";
            }
        }
        if (!this.cpuControlled) {
            text(cStr + " Zone: Only\nplayers of " + cStr + " color can enter.", 300, 250);
        }
        textFont(createFont("AvenirNext-UltraLight"));
        /*if (dist(this.x, this.y, colorZones[i][0], colorZones[i][1]) < colorZones[i][2] / 2) {
            this.x = this.oldx;
            this.y = this.oldy;
            this.health --;
        }*/
        this.colorsOn = [];
        for (var i = 0 ; i < colorZones.length ; i++) {
            if (dist(this.x, this.y, colorZones[i][0], colorZones[i][1]) < colorZones[i][2] / 2) {
                this.colorsOn.push(colorZones[i][3]);
            }
        }
        this.allowed = false;
        if (this.colorsOn.length === 0) {
            this.allowed = true;
        }
        for (var i = 0 ; i < this.colorsOn.length ; i++) {
            if (this.colorsOn[i] + 1 === Player1.color) {
                this.allowed = true;
            }
        }
        if (!this.allowed) {
            this.x = this.oldx;
            this.y = this.oldy;
            if (frameCount % 10 === 0) {
                this.health --;
                if (this.health <= 0) {
                    this.killInd = "Color";
                }
            }
        }
    }
    this.inBeach = false;
    for (var i = 0 ; i < beaches.length ; i++) {
        if (dist(this.x, this.y, beaches[i][0], beaches[i][1]) > beaches[i][2] && dist(this.x, this.y, beaches[i][0], beaches[i][1]) < beaches[i][3]) {
            this.inBeach = true;
        }
    }
    /*this.nearBoat = false;
    for (var i = 0 ; i < boats.length ; i++) {
        if (dist(this.x, this.y, boats[i].x, boats[i].y) < 60 && !this.inBoat) {
            this.nearBoat = true;
            this.boatInd = i;
        }
    }
    if (this.nearBoat) {
        if (!this.cpuControlled) {
            fill(0, 0, 0);
            textSize(20);
            textFont(createFont("Avenir"));
            text("Press SPACE to enter boat.", 300, 300);
            textFont(createFont("AvenirNext-UltraLight"));
            if (keys[32] && spacepressed) {
                this.inBoat = true;
                this.boatframe = 0;
                this.oldx = this.x;
                this.oldy = this.y;
            }
        }
    }
    if (this.inBoat && !this.cpuControlled) {
        this.nearBoat = false;
        this.x = boats[this.boatInd].x;
        this.y = boats[this.boatInd].y;
        this.ang = boats[this.boatInd].ang;
        if (keys[UP] && boats[this.boatInd].moveSpeed < 12) {
            boats[this.boatInd].moveSpeed += 0.3;
        }
        if (keys[RIGHT]) {
            boats[this.boatInd].ang -= 3;
        }
        if (keys[LEFT]) {
            boats[this.boatInd].ang += 3;
        }
        if (!boats[this.boatInd].inLake) {
            fill(0, 0, 0);
            textSize(20);
            textFont(createFont("Avenir"));
            text("Press SPACE to exit boat.", 300, 300);
            textFont(createFont("AvenirNext-UltraLight"));
            if (keys[32] && spacepressed && this.boatframe > 0) {
                this.inBoat = false;
                var b = boats[this.boatInd];
                this.x = b.x + 60 * cos(-b.ang - 90);
                this.y = b.y + 60 * sin(-b.ang - 90);
                //this.x = this.oldx;
                //this.y = this.oldy;
            }
        }
        this.boatframe ++;
    }*/
    for (var i = 0 ; i < lakes.length ; i++) {
        this.clake = true;
        if (lakes[i][4]) {
            if ((lakes[i][4] / 2) - Math.abs((lakes[i][4] / 2) - ((Math.atan2(this.y - lakes[i][1], this.x - lakes[i][0]) * (180 / Math.PI) + 360) % 360) % (lakes[i][4])) < 3.3) {
                this.clake = false;
            }
        }
        if (dist(this.x, this.y, lakes[i][0], lakes[i][1]) < lakes[i][2] / 2 && (!lakes[i][3] || dist(this.x, this.y, lakes[i][0], lakes[i][1]) > lakes[i][3] / 2) && !this.inBoat && this.clake) {
            this.x = this.prevx;
            this.y = this.prevy;
            
            fill(0, 0, 0);
            this.bodyOfWater = true;
        }
    }
    /*this.dropped = [];
    for (var i = 0 ; i < droppedItems.length ; i++) {
        if (dist(droppedItems[i][1], droppedItems[i][2], this.x, this.y) < 25) {
            this.dropped.push(droppedItems[i]);
        }
    }*/
    
    /*if (this.dropped.length > 0 && !this.cpuControlled) {
        fill(0, 0, 0);
        textSize(20);
        textFont(createFont("Avenir"));
        text("Press SHIFT to pick up the items", 300, 400);
        textFont(createFont("AvenirNext-UltraLight"));
        if (keys[16]) {
            for (var i = 0 ; i < this.dropped.length ; i++) {
                this.les = "None";
                for (var j = 0 ; j < this.inventory.length ; j++) {
                    if (this.inventory[j] === "Empty Space" && this.les === "None") {
                        this.les = j;
                    }
                }
                if (this.les !== "None") {
                    this.inventory[this.les] = itemList[this.dropped[i][0]];
                    droppedItems.splice(droppedItems.indexOf(this.dropped[i]), 1);
                }
            }
        }
    }*/
    if (!this.cpuControlled) {
        
        if (!validPoint(this.x, this.y)) {
                
                //this.x = this.treeprevx;
                //this.y = this.treeprevy;
            
        }
    }
    this.prevsec = second();
    this.prevx = this.x;
    this.prevy = this.y;
    this.dist += dist(this.x, this.y, this.surprevx, this.surprevy);
};

Player.prototype.die = function() {
    if (this.cpuControlled && !this.dead) {
        this.dead = true;
        if (this.killInd === "Fang") {
            messages.push([this.name + " died from a dark and powerful fang", messageTick]);
        }
        else if (this.killInd === "Border") {
            messages.push([this.name + " was caught outside of the shrinking map", messageTick]);
        }
        else if (this.killInd === "Thirst") {
            messages.push([this.name + " died of thirst", messageTick]);
        }
        else if (this.killInd === "Color") {
            messages.push([this.name + " entered an unauthorized color zone", messageTick]);
        }
        else if (this.killInd === "Poison") {
            messages.push([this.name + " ate a poisonous berry", messageTick]);
        }
        else if (this.killInd === "Hunger") {
            messages.push([this.name + " died of thirst", messageTick]);
        }
        else {
            messages.push([this.name + " was eliminated by " + players[this.killInd].name, messageTick]);
        }
        /*for (var i = 0 ; i < this.inventory.length ; i++) {
            if (this.inventory[i] !== "Empty Space" && random(1, 5) < 2) {
                droppedItems.push([itemList.indexOf(this.inventory[i]), this.x + random(-100, 100), this.y + random(-100, 100)]);
            }
        }*/
        splicinds.push(players.indexOf(this));
    }
    else if (!this.cpuControlled) {
        newscene = "Eliminated";
        this.strength -= characterStats[selch][0];
        this.speed -= characterStats[selch][1];
        this.stamina -= characterStats[selch][2];
    }
};

Player.prototype.checkInventory = function() {
    this.iInd = 0;
    while (this.iInd < 27 && this.inventory[this.iInd] !== "Empty Space") {
        this.iInd ++;
    }
    if (this.iInd === 27) {
        this.inventoryFull = true;
        this.lastEmptySpace = "Full";
    }
    else {
        this.inventoryFull = false;
        this.lastEmptySpace = this.iInd;
    }
};

Player.prototype.display = function() {
    if (!this.cpuControlled) {
        this.draww();
        this.update();
        this.checkInventory();
    }
    else {
        this.draww();
        this.update();
        this.AIUpdate();
        this.checkInventory();
    }
};

var Player1 = new Player();

var players = [];

var surnames = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Miller", "Davis", "Garcia", "Rodriguez", "Wilson", "Martinez", "Anderson", "Taylor", "Thomas", "Hernandez", "Moore", "Martin", "Jackson", "Thompson", "White", "Lopez", "Lee", "Gonzalez", "Harris", "Clark", "Lewis", "Robinson", "Walker", "Perez", "Hall", "Young", "Allen", "Sanchez", "Wright", "King", "Scott", "Green", "Baker", "Adams", "Nelson", "Hill", "Ramirez", "Campbell", "Mitchell", "Roberts", "Carter", "Phillips", "Evans", "Turner", "Torres", "Parker", "Collins", "Edwards", "Stewart", "Flores", "Morris", "Nguyen", "Murphy", "Rivera", "Cook", "Rogers", "Morgan", "Peterson", "Cooper", "Reed", "Bailey", "Bell", "Gomez", "Kelly", "Howard", "Ward", "Cox", "Diaz", "Richardson", "Wood", "Watson", "Brooks", "Bennett", "Gray", "James", "Reyes", "Cruz", "Hughes", "Price", "Myers", "Long", "Foster", "Sanders", "Ross", "Morales", "Powell", "Sullivan", "Russell", "Ortiz", "Jenkins", "Gutierrez", "Perry", "Butler", "Barnes", "Fisher", "Henderson", "Coleman", "Simmons", "Patterson", "Jordan", "Reynolds", "Hamilton", "Graham", "Kim", "Gonzales", "Alexander", "Ramos", "Wallace", "Griffin", "West", "Cole", "Hayes", "Chavez", "Gibson", "Bryant", "Ellis", "Stevens", "Murray", "Ford", "Marshall", "Owens", "Mcdonald", "Harrison", "Ruiz", "Kennedy", "Wells", "Alvarez", "Woods", "Mendoza", "Castillo", "Olson", "Webb", "Washington", "Tucker", "Freeman", "Burns", "Henry", "Vasquez", "Snyder", "Simpson", "Crawford", "Jimenez", "Porter", "Mason", "Shaw", "Gordon", "Wagner", "Hunter", "Romero", "Hicks", "Dixon", "Hunt", "Palmer", "Robertson", "Black", "Holmes", "Stone", "Meyer", "Boyd", "Mills", "Warren", "Fox", "Rose", "Rice", "Moreno", "Schmidt", "Patel", "Ferguson", "Nichols", "Herrera", "Medina", "Ryan", "Fernandez", "Weaver", "Daniels", "Stephens", "Gardner", "Payne", "Kelley", "Dunn", "Pierce", "Arnold", "Tran", "Spencer", "Peters", "Hawkins", "Grant", "Hansen", "Castro", "Hoffman", "Hart", "Elliott", "Cunningham", "Knight", "Bradley", "Carroll", "Hudson", "Duncan", "Armstrong", "Berry", "Andrews", "Johnston", "Ray", "Lane", "Riley", "Carpenter", "Perkins", "Aguilar", "Silva", "Richards", "Willis", "Matthews", "Chapman", "Lawrence", "Garza", "Vargas", "Watkins", "Wheeler", "Larson", "Carlson", "Harper", "George", "Greene", "Burke", "Guzman", "Morrison", "Munoz", "Jacobs", "Obrien", "Lawson", "Franklin", "Lynch", "Bishop", "Carr", "Salazar", "Austin", "Mendez", "Gilbert", "Jensen", "Williamson", "Montgomery", "Harvey", "Oliver", "Howell", "Dean", "Hanson", "Weber", "Garrett", "Sims", "Burton", "Fuller", "Soto", "Mccoy", "Welch", "Chen", "Schultz", "Walters", "Reid", "Fields", "Walsh", "Little", "Fowler", "Bowman", "Davidson", "May", "Day", "Schneider", "Newman", "Brewer", "Lucas", "Holland", "Wong", "Banks", "Santos", "Curtis", "Pearson", "Delgado", "Valdez", "Pena", "Rios", "Douglas", "Sandoval", "Barrett", "Hopkins", "Keller", "Guerrero", "Stanley", "Bates", "Alvarado", "Beck", "Ortega", "Wade", "Estrada", "Contreras", "Barnett", "Caldwell", "Santiago", "Lambert", "Powers", "Chambers", "Nunez", "Craig", "Leonard", "Lowe", "Rhodes", "Byrd", "Gregory", "Shelton", "Frazier", "Becker", "Maldonado", "Fleming", "Vega", "Sutton", "Cohen", "Jennings", "Parks", "Mcdaniel", "Watts", "Barker", "Norris", "Vaughn", "Vazquez", "Holt", "Schwartz", "Steele", "Benson", "Neal", "Dominguez", "Horton", "Terry", "Wolfe", "Hale", "Lyons", "Graves", "Haynes", "Miles", "Park", "Warner", "Padilla", "Bush", "Thornton", "Mccarthy", "Mann", "Zimmerman", "Erickson", "Fletcher", "Mckinney", "Page", "Dawson", "Joseph", "Marquez", "Reeves", "Klein", "Espinoza", "Baldwin", "Moran", "Love", "Robbins", "Higgins", "Ball", "Cortez", "Le", "Griffith", "Bowen", "Sharp", "Cummings", "Ramsey", "Hardy", "Swanson", "Barber", "Acosta", "Luna", "Chandler", "Daniel", "Blair", "Cross", "Simon", "Dennis", "Oconnor", "Quinn", "Gross", "Navarro", "Moss", "Fitzgerald", "Doyle", "Mclaughlin", "Rojas", "Rodgers", "Stevenson", "Singh", "Yang", "Figueroa", "Harmon", "Newton", "Paul", "Manning", "Garner", "Mcgee", "Reese", "Francis", "Burgess", "Adkins", "Goodman", "Curry", "Brady", "Christensen", "Potter", "Walton", "Goodwin", "Mullins", "Molina", "Webster", "Fischer", "Campos", "Avila", "Sherman", "Todd", "Chang", "Blake", "Malone", "Wolf", "Hodges", "Juarez", "Gill", "Farmer", "Hines", "Gallagher", "Duran", "Hubbard", "Cannon", "Miranda", "Wang", "Saunders", "Tate", "Mack", "Hammond", "Carrillo", "Townsend", "Wise", "Ingram", "Barton", "Mejia", "Ayala", "Schroeder", "Hampton", "Rowe", "Parsons", "Frank", "Waters", "Strickland", "Osborne", "Maxwell", "Chan", "Deleon", "Norman", "Harrington", "Casey", "Patton", "Logan", "Bowers", "Mueller", "Glover", "Floyd", "Hartman", "Buchanan", "Cobb", "French", "Kramer", "Mccormick", "Clarke", "Tyler", "Gibbs", "Moody", "Conner", "Sparks", "Mcguire", "Leon", "Bauer", "Norton", "Pope", "Flynn", "Hogan", "Robles", "Salinas", "Yates", "Lindsey", "Lloyd", "Marsh", "Mcbride", "Owen", "Solis", "Pham", "Lang", "Pratt", "Lara", "Brock", "Ballard", "Trujillo", "Shaffer", "Drake", "Roman", "Aguirre", "Morton", "Stokes", "Lamb", "Pacheco", "Patrick", "Cochran", "Shepherd", "Cain", "Burnett", "Hess", "Li", "Cervantes", "Olsen", "Briggs", "Ochoa", "Cabrera", "Velasquez", "Montoya", "Roth", "Meyers", "Cardenas", "Fuentes", "Weiss", "Wilkins", "Hoover", "Nicholson", "Underwood", "Short", "Carson", "Morrow", "Colon", "Holloway", "Summers", "Bryan", "Petersen", "Mckenzie", "Serrano", "Wilcox", "Carey", "Clayton", "Poole", "Calderon", "Gallegos", "Greer", "Rivas", "Guerra", "Decker", "Collier", "Wall", "Whitaker", "Bass", "Flowers", "Davenport", "Conley", "Houston", "Huff", "Copeland", "Hood", "Monroe", "Massey", "Roberson", "Combs", "Franco", "Larsen", "Pittman", "Randall", "Skinner", "Wilkinson", "Kirby", "Cameron", "Bridges", "Anthony", "Richard", "Kirk", "Bruce", "Singleton", "Mathis", "Bradford", "Boone", "Abbott", "Charles", "Allison", "Sweeney", "Atkinson", "Horn", "Jefferson", "Rosales", "York", "Christian", "Phelps", "Farrell", "Castaneda", "Nash", "Dickerson", "Bond", "Wyatt", "Foley", "Chase", "Gates", "Vincent", "Mathews", "Hodge", "Garrison", "Trevino", "Villarreal", "Heath", "Dalton", "Valencia", "Callahan", "Hensley", "Atkins", "Huffman", "Roy", "Boyer", "Shields", "Lin", "Hancock", "Grimes", "Glenn", "Cline", "Delacruz", "Camacho", "Dillon", "Parrish", "Oneill", "Melton", "Booth", "Kane", "Berg", "Harrell", "Pitts", "Savage", "Wiggins", "Brennan", "Salas", "Marks", "Russo", "Sawyer", "Baxter", "Golden", "Hutchinson", "Liu", "Walter", "Mcdowell", "Wiley", "Rich", "Humphrey", "Johns", "Koch", "Suarez", "Hobbs", "Beard", "Gilmore", "Ibarra", "Keith", "Macias", "Khan", "Andrade", "Ware", "Stephenson", "Henson", "Wilkerson", "Dyer", "Mcclure", "Blackwell", "Mercado", "Tanner", "Eaton", "Clay", "Barron", "Beasley", "Oneal", "Small", "Preston", "Wu", "Zamora", "Macdonald", "Vance", "Snow", "Mcclain", "Stafford", "Orozco", "Barry", "English", "Shannon", "Kline", "Jacobson", "Woodard", "Huang", "Kemp", "Mosley", "Prince", "Merritt", "Hurst", "Villanueva", "Roach", "Nolan", "Lam", "Yoder", "Mccullough", "Lester", "Santana", "Valenzuela", "Winters", "Barrera", "Orr", "Leach", "Berger", "Mckee", "Strong", "Conway", "Stein", "Whitehead", "Bullock", "Escobar", "Knox", "Meadows", "Solomon", "Velez", "Odonnell", "Kerr", "Stout", "Blankenship", "Browning", "Kent", "Lozano", "Bartlett", "Pruitt", "Buck", "Barr", "Gaines", "Durham", "Gentry", "Mcintyre", "Sloan", "Rocha", "Melendez", "Herman", "Sexton", "Moon", "Hendricks", "Rangel", "Stark", "Lowery", "Hardin", "Hull", "Sellers", "Ellison", "Calhoun", "Gillespie", "Mora", "Knapp", "Mccall", "Morse", "Dorsey", "Weeks", "Nielsen", "Livingston", "Leblanc", "Mclean", "Bradshaw", "Glass", "Middleton", "Buckley", "Schaefer", "Frost", "Howe", "House", "Mcintosh", "Ho", "Pennington", "Reilly", "Hebert", "Mcfarland", "Hickman", "Noble", "Spears", "Conrad", "Arias", "Galvan", "Velazquez", "Huynh", "Frederick", "Randolph", "Cantu", "Fitzpatrick", "Mahoney", "Peck", "Villa", "Michael", "Donovan", "Mcconnell", "Walls", "Boyle", "Mayer", "Zuniga", "Giles", "Pineda", "Pace", "Hurley", "Mays", "Mcmillan", "Crosby", "Ayers", "Case", "Bentley", "Shepard", "Everett", "Pugh", "David", "Mcmahon", "Dunlap", "Bender", "Hahn", "Harding", "Acevedo", "Raymond", "Blackburn", "Duffy", "Landry", "Dougherty", "Bautista", "Shah", "Potts", "Arroyo", "Valentine", "Meza", "Gould", "Vaughan", "Fry", "Rush", "Avery", "Herring", "Dodson", "Clements", "Sampson", "Tapia", "Bean", "Lynn", "Crane", "Farley", "Cisneros", "Benton", "Ashley", "Mckay", "Finley", "Best", "Blevins", "Friedman", "Moses", "Sosa", "Blanchard", "Huber", "Frye", "Krueger", "Bernard", "Rosario", "Rubio", "Mullen", "Benjamin", "Haley", "Chung", "Moyer", "Choi", "Horne", "Yu", "Woodward", "Ali", "Nixon", "Hayden", "Rivers", "Estes", "Mccarty", "Richmond", "Stuart", "Maynard", "Brandt", "Oconnell", "Hanna", "Sanford", "Sheppard", "Church", "Burch", "Levy", "Rasmussen", "Coffey", "Ponce", "Faulkner", "Donaldson", "Schmitt", "Novak", "Costa", "Montes", "Booker", "Cordova", "Waller", "Arellano", "Maddox", "Mata", "Bonilla", "Stanton", "Compton", "Kaufman", "Dudley", "Mcpherson", "Beltran", "Dickson", "Mccann", "Villegas", "Proctor", "Hester", "Cantrell", "Daugherty", "Cherry", "Bray", "Davila", "Rowland", "Madden", "Levine", "Spence", "Good", "Irwin", "Werner", "Krause", "Petty", "Whitney", "Baird", "Hooper", "Pollard", "Zavala", "Jarvis", "Holden", "Hendrix", "Haas", "Mcgrath", "Bird", "Lucero", "Terrell", "Riggs", "Joyce", "Rollins", "Mercer", "Galloway", "Duke", "Odom", "Andersen", "Downs", "Hatfield", "Benitez", "Archer", "Huerta", "Travis", "Mcneil", "Hinton", "Zhang", "Hays", "Mayo", "Fritz", "Branch", "Mooney", "Ewing", "Ritter", "Esparza", "Frey", "Braun", "Gay", "Riddle", "Haney", "Kaiser", "Holder", "Chaney", "Mcknight", "Gamble", "Vang", "Cooley", "Carney", "Cowan", "Forbes", "Ferrell", "Davies", "Barajas", "Shea", "Osborn", "Bright", "Cuevas", "Bolton", "Murillo", "Lutz", "Duarte", "Kidd", "Key", "Cooke"];

var firstnames = ["Jackson","Aiden","Liam","Lucas","Mason","Ethan","Caden","Jacob","Logan","Jayden","Elijah","Jack","Luke","Michael","Benjamin","Alexander","James","Jayce","Caleb","Connor","William","Carter","Ryan","Oliver","Matthew","Daniel","Gabriel","Henry","Owen","Grayson","Dylan","Landon","Isaac","Nicholas","Wyatt","Nathan","Andrew","Cameron","Dominic","Joshua","Eli","Sebastian","Hunter","Brayden","David","Samuel","Evan","Gavin","Christian","Max","Anthony","Joseph","Julian","John","Colton","Levi","Muhammad","Isaiah","Aaron","Tyler","Charlie","Adam","Parker","Austin","Thomas","Zachary","Nolan","Alex","Ian","Jonathan","Christopher","Cooper","Hudson","Miles","Adrian","Leo","Blake","Lincoln","Jordan","Tristan","Jason","Josiah","Xavier","Camden","Chase","Declan","Carson","Colin","Brody","Asher","Jeremiah","Micah","Easton","Xander","Ryder","Nathaniel","Elliot","Sean","Cole", "Sophia",'Emma','Olivia','Ava','Isabella','Mia','Zoe','Lily','Emily','Madelyn','Madison','Chloe','Charlotte','Aubrey','Avery','Abigail','Kaylee','Layla','Harper','Ella','Amelia','Arianna','Riley','Aria','Hailey','Hannah','Aaliyah','Evelyn','Addison','Mackenzie','Adalyn','Ellie','Brooklyn','Nora','Scarlett','Grace','Anna','Isabelle','Natalie','Kaitlyn','Lillian','Sarah','Audrey','Elizabeth','Leah','Annabelle','Kylie','Mila','Claire','Victoria','Maya','Lila','Elena','Lucy','Savannah','Gabriella','Callie','Alaina','Sophie','Makayla','Kennedy','Sadie','Skyler','Allison','Caroline','Charlie','Penelope','Alyssa','Peyton','Samantha','Liliana','Bailey','Maria','Reagan','Violet','Eliana','Adeline','Eva','Stella','Keira','Katherine','Vivian','Alice','Alexandra','Camilla','Kayla','Alexis','Sydney','Kaelyn','Jasmine','Julia','Cora','Lauren','Piper','Gianna','Paisley','Bella','London','Clara','Cadence'];


var AI = function() {
    this.firstName = firstnames[round(random(-0.4, firstnames.length - 0.6))];
    this.lastName = surnames[round(random(-0.4, surnames.length - 0.6))];
    this.rareRand = round(random(-0.4, 4.4));
    this.rareOptions = [this.firstName.toUpperCase() + "_THE_GREAT", this.firstName.split("")[0].toLowerCase() + this.lastName.split("")[0].toLowerCase() + "gamer", this.firstName + " " + this.lastName.split("")[0] + ".", "Awesome" + this.firstName, this.firstName.toUpperCase() + "THEBOSS", this.lastName + round(random(3, 1000)).toString()];
    this.rand = round(random(-0.4, 3.4));
    
    this.nameOptions = [this.firstName.split("")[0].toLowerCase() + this.lastName.toLowerCase() + round(random(6, 1000)).toString(), this.firstName + "_" + this.lastName, this.firstName.toLowerCase() + this.lastName.split("")[0].toLowerCase() + round(random(3, 1000)).toString(), this.rareOptions[this.rareRand]];
    this.name = this.nameOptions[this.rand];
    this.strength = round(random(-0.4, 12.4));
    this.speed = round(random(-0.4, 12.4));
    this.stamina = round(random(0.6, 12.4));
    this.score = round((this.strength + this.speed + this.stamina) / 3);
    this.color = color(255, 255, 255);
    this.stats = [this.strength, this.speed, this.stamina];
    
    this.strategy = [function() { var xvar = Math.random(1); if (xvar < 0.15) { return 0; } else if (xvar < 0.4) { return 2; } else { return 1; }}, round(random(-0.4, 2.4)), round(random(-0.4, 2.4)), random(0, 1), round(random(-0.4, 2.4)), this.timelimit, round(random(-0.4, 1.4)), round(random(0.6, 4.4)), round(random(0, 7)) / 2];
    this.timelimit = 0;
    /*
    AI STRATEGIES
    0: Go To Center
    "Timid"
    Flee immediately
    "Normal"
    Grab weak items at the outskirts, then flee
    "Aggressive"
    Go directly to center
    1: Opponent Encounters
    "Timid"
    Flee whenever another player is seen
    "Normal"
    Attack if holding a better weapon than an opponent, otherwise flee
    "Aggressive"
    Always attack any player that is seen
    2: Food and Water Urgency
    "Wimpy"
    Always look for food and water
    "Normal"
    Looks for food and water sometimes, when their bar is getting considerably low
    "Survivor"
    Only looks for food and water if they are dying of hunger or thirst
    3: Intelligence
    Value from 0 to 1. 1 is smart and 0 is not smart.
    This value determines:
    -Whether the player will play a "pool shark" strategy, i.e. not showing their weapon until a player has began to attack them, in order to attract "Normal" type players.
    -How much information the player will reveal in interviews. Very intelligent players might lie during these interviews.
    4: Inventory Greediness NOT USED IN GAME
    "Greedy"
    Picks up every dropped item and every item from a chest.
    "Normal"
    Picks up every dropped item and chest item that they don't already have
    "Conservative"
    Picks up only very useful items, including mythical items.
    5: Time before fleeing center
    6: Focus: 0 = Players, 1 = Chests
    7: Chest Tolerance
    8: Lowest Dropped Item value
    */
};

var ai = [];
for (var i = 0 ; i < 500 ; i++) {
    ai.push(new AI());
}

var districtStats = [[7, 8, 3], [10, 4, 5], [4, 5, 5], [8, 7, 8], [5, 7, 7], [3, 5, 2], [9, 6, 8], [3, 3, 7], [2, 2, 5], [7, 3, 6], [4, 10, 8], [4, 7, 10]];
var spfac = 700;

var weaponValues = [2, 3, 4, 5, 4.5, 5.5, 6.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0];
var droppedValues = [0, 1, 2, 3, 4, 2.5, 3, 3.5, 0.5, 0.7, 1.1, 1.5, 2, 2.1, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 4.5, 6, 5.5, 4.2, 3.2, 4.3, 0.2, 1.7];

var degreeDifference = function(d1, d2) {
    d1 = d1 % 360;
    d2 = d2 % 360;
    return Math.min(Math.abs(d2 - d1), 360 - Math.abs(d2 - d1));
};

var items;
var stritems;
var trueitems;

var AIPlayer = function(startPos, playersInGame, name, strategy, stats, tl) {
    this.risky = false;
    this.tol = round(random(10, 25));
    if (random(0, 1) < 0.1) {
        this.risky = true;
    }
    this.colTCO = false;
    this.colColor = false;
    this.colColorVal = 0;
    this.colLake = false;
    this.posArr = [];
    this.panicFrame = 0;
    this.stagnationFrame = 0;
    this.poisoned = false;
    this.outon = 0;
    this.chestInd = "No Chest";
    this.attackCooldown = 0;
    this.ang = 0;
    this.kills = 0;
    this.name = name;
    this.startPos = startPos;
    this.pig = playersInGame;
    this.fleePos = [300 + cos((startPos - 1)* (360 / playersInGame) - 90) * 5000, 300 + sin((startPos - 1) * (360 / playersInGame) - 90) * 5000];
    this.x = 300 + cos((startPos - 1)* (360 / playersInGame) - 90) * spfac;
    this.y = 300 + sin((startPos - 1) * (360 / playersInGame) - 90) * spfac;
    this.target = [this.x, this.y];
    this.firstfound = false;
    this.color = color(255, 255, 255);
    this.cpuControlled = true;
    this.vel = PVector(0, 0);
    this.pos = PVector(this.x, this.y);
    this.strategy = strategy;
    this.inventory = [];
    for (var i = 0 ; i < 27 ; i++) {
        this.inventory.push("Empty Space");
    }
    this.looted = [];
    this.weapon = "";
    this.forceframe = 0;
    this.weaponInd = "No Weapon";
    this.weaponIcon = "No Weapon";
    this.takingDamage = false;
    this.takingDamageFrame = 0;
    this.health = 100;
    this.firstArrow = 0;
    this.arrowcount = [];
    this.healthCount = [];
    this.polyjuiceCount = [];
    this.arrow = true;
    for (var i = 0 ; i < 27 ; i++) {
       this.inventory.push("Empty Space");
       this.arrowcount.push(0);
       this.healthCount.push(0);
       this.polyjuiceCount.push(0);
    }
    this.weapon = "";
    this.weaponInd = "No Weapon";
    this.weaponIcon = 0;
    this.takingDamage = false;
    this.takingDamageFrame = 0;
    this.health = 100;
    this.arrow = false;
    this.prevsec = second();
    this.gone = false;
    this.strColorTime = "";
    this.nearPlayerDir = 0;
    this.thirst = 100;
    if (this.strategy[0] === 0.5) {
        if (random(0, 1) <= 0.5) {
            this.strategy[0] = 0;
        }
        else {
            this.strategy[0] = 1;
        }
    }
    if (this.strategy[0] === 1.5) {
        if (random(1, 2) <= 1.5) {
            this.strategy[0] = 1;
        }
        else {
            this.strategy[0] = 2;
        }
    }
    this.onCenterRun = true;
    this.lockedOn = false;
    this.onChest = false;
    this.cooldown = 0;
    this.cooldownFactor = random(5, 15);
    this.hitCooldownFactor = random(3, 13);
    this.dx = 0;
    this.dy = 0;
    this.gotToCenter = false;
    this.timelimit = this.strategy[5];
    this.stats = stats;
    this.strength = this.stats[0];
    this.speed = this.stats[1];
    this.stamina = this.stats[2];
    this.trainingScore = (this.stats[0] + this.stats[1] + this.stats[2]) / 3;
    this.aiprevx = this.x;
    this.aiprevy = this.y;
    this.timelimit = random(200, 2000);
    if (random(1) < 0.8 && this.strategy[0] >= 1) {
        this.immediateCenter = random(200, 500);
        this.immediateGoing = true;
    }
};

var mapSeed = 1;

AIPlayer.prototype = Object.create(Player.prototype);

AIPlayer.prototype.AIUpdate = function() {
    this.posArr.push([this.x, this.y]);
    this.panicFrame --;
    this.stagnationFrame --;
    //this.turning = false;
    //this.hittingtree = false;
    this.treeprevx = this.x;
    this.treeprevy = this.y;
    if (this.looted.length === 0) {
        for (var i = 0 ; i < chests.length ; i++) {
            this.looted.push(false);
        }
    }
    for (var i = 0 ; i < lakes.length ; i++) {
        if (dist(this.x, this.y, lakes[i][0], lakes[i][1]) < lakes[i][2] / 2 + 50 && (!lakes[i][3] || dist(this.x, this.y, lakes[i][0], lakes[i][1]) > lakes[i][3] / 2)) {
            this.colLake = true;
            for (var i = 0 ; i < this.inventory.length ; i++) {
                if (this.inventory[i] === "Empty Bottle") {
                    this.inventory[i] = "Bottle of Water";
                }
            }
        }
    }
    //if (!this.firstfound) {
    //    this.target = [thisx
    //this.ang = Math.atan2(this.y - this.aiprevy, this.x - this.aiprevx) * (180 / Math.PI);
    this.aiprevx = this.x;
    this.aiprevy = this.y;
    this.moved = false;
    if (frameCount % 20 === 0) {
    }
    
    //this.goneToLoc = false;
    this.seePlayers = false;
    this.playersSeen = [];
    /*for (var i = 0 ; i < players.length ; i++) {
        if (players[i].x > this.x - 300 && players[i].x < this.x + 300 && players[i].y > this.y - 300 && players[i].y < this.y + 300 && players[i] !== this) {
            this.seePlayers = true;
            this.playersSeen.push([players[i].x, players[i].y]);
        }
    }*/
    //if (this.seePlayers) {
        /*if (this.strategy[1] === 0) {
            this.avg = [0, 0];
            this.min = 100000000;
            this.minx = [];
            for (var i = 0 ; i < this.playersSeen.length ; i++) {
                this.avg[0] += this.playersSeen[i][0];
                this.avg[1] += this.playersSeen[i][1];
                if (dist(this.x, this.y, this.playersSeen[i][0], this.playersSeen[i][1]) < this.min) {
                    this.min = dist(this.x, this.y, this.playersSeen[i][0], this.playersSeen[i][1]);
                    this.minx = [this.playersSeen[i][0], this.playersSeen[i][1]];
                }
            }
            this.avg = [this.avg[0] / this.playersSeen.length, this.avg[1] / this.playersSeen.length];
            //if (this.min > 20) {
                this.goAwayFrom(this.min[0], this.min[1]);
            //}
            //this.flee();
        }
        if (this.strategy[1] >= 1) {
            this.avg = [0, 0];
            this.min = 100000000;
            for (var i = 0 ; i < this.playersSeen.length ; i++) {
                this.avg[0] += this.playersSeen[i][0];
                this.avg[1] += this.playersSeen[i][1];
                if (dist(this.x, this.y, this.playersSeen[i][0], this.playersSeen[i][1]) < this.min) {
                    this.min = dist(this.x, this.y, this.playersSeen[i][0], this.playersSeen[i][1]);
                    this.minx = [this.playersSeen[i][0], this.playersSeen[i][1]];
                }
            }
            this.avg = [this.avg[0] / this.playersSeen.length, this.avg[1] / this.playersSeen.length];
            this.goToLocation(this.min[0], this.min[1]);
        }*/
        //if (this.srategy[1] === 1) {
            
    //}
    this.loots = 0;
    if (dist(this.x, this.y, 300, 300) < 50) {
        //this.gotToCenter = true;
    }
    /*for (var i = 0 ; i < chests.length ; i++) {
        /*if (chests[i].x > this.x - 300 && chests[i].x < this.x + 300 && chests[i].y > this.y - 300 && chests[i].y < this.y + 300 && !this.goneToLoc && (!this.lockedOn || this.lockedOn === i + 1) && !this.onChest && this.looted[i] === false && (this.strategy[0] !== 0 || dist(this.x, this.y, 300, 300) > 1200) && (this.strategy[0] !== 1 || this.il <= 3 || dist(this.x, this.y, 300, 300) > 2400) && (this.strategy[0] !== 2 || !this.gotToCenter)) {
            this.onCenterRun = false;
            this.goToLocation(chests[i].x, chests[i].y);
            this.lockedOn = i + 1;
            break;
        }
        if (chests[i].x > this.x - 300 && chests[i].x < this.x + 300 && chests[i].y > this.y - 300 && chests[i].y < this.y + 300 && (!this.lockedOn || this.lockedOn === i + 1) && !this.onChest && this.looted[i] === false) {
            
            var goto = false;
            if (this.strategy[0] === 0) {
                if (dist(this.x, this.y, 300, 300) > 1200) {
                    goto = true;
                }
            }
            if (this.strategy[0] === 1) {
                if ((this.il <= 3 && matchtime < this.timelimit) || dist(this.x, this.y, 300, 300) > 2400) {
                    goto = true;
                }
            }
            if (this.strategy[0] === 2) {
                if ((this.il <= 15 && matchtime < this.timelimit) || dist(this.x, this.y, 300, 300) > 2400) {
                    goto = true;
                }
            }
            if (goto && !this.gotToCenter) {
                this.onCenterRun = false;
                this.goToLocation(chests[i].x, chests[i].y);
                this.lockedOn = i + 1;
                break;
            }
        }
        if (this.looted[i]) {
            this.loots ++;
        }
    }*/
    if (!this.lockedOn && !this.gotToCenter) {
        //this.goToLocation(300, 300);
    }
    if (this.gotToCenter) {
        //this.goAwayFrom(300, 300);
    }
    if (this.strategy[0] === 0) {
        //this.goToLocation(this.fleePos[0], this.fleePos[1]);
    }
    if (this.onCenterRun && this.strategy[0] >= 1) {
        //this.goToLocation(300, 300);
    }
    if (this.lockedOn) {
        if (this.x > chests[this.lockedOn - 1].x - 30 && this.x < chests[this.lockedOn - 1].x + 30 && this.y > chests[this.lockedOn - 1].y - 30 && this.y < chests[this.lockedOn - 1].y + 30) {
            this.onChest = true;
        }
    }
    /*if (this.onChest && frameCount % 5 === 0) {
        var i = 0;
        while ((chests[this.lockedOn - 1].items[i] === "Empty Space" && i < chests[this.lockedOn - 1].items.length) || !this.worthIt(chests[this.lockedOn - 1])) {
            i ++;
        }
        if (i !== chests[this.lockedOn - 1].items.length) {
            this.inventory[this.lastEmptySpace] = chests[this.lockedOn - 1].items[i];
            chests[this.lockedOn - 1].items[i] = "Empty Space";
        }
        else {
            this.looted[this.lockedOn - 1] = true;
            this.lockedOn = false;
            this.onChest = false;
            //this.onCenterRun = true;
        }
    }*/
    this.il = 0;
    for (var i = 0 ; i < this.inventory.length ; i++) {
        if (this.inventory[i] !== "Empty Space") {
            this.il ++;
        }
        this.healthInd = itemList.indexOf(this.inventory[i]);
        if (this.healthInd >= 9 && this.healthInd <= 12 && this.health < 60) {
            if (this.healthInd === 9) {
                this.health += round(random(0.6, 25.4));
            }
            if (this.healthInd === 10) {
                this.health += round(random(24.6, 50.4));
            }
            if (this.healthInd === 11) {
                this.health += round(random(49.6, 99.4));
            }
            if (this.healthInd === 12) {
                this.health = 100;
            }
        }
        if (this.healthInd >= 14 && this.healthInd <= 19 && this.colColor && this.colColorVal === this.healthInd - 13) {
            this.color = this.healthInd - 13;
            this.colTCO = true;
            this.polyColor = false;
            this.colorTime = 120;
        }
        if (this.healthInd === 27 && this.thirst < 80) {
            this.thirst += random(30, 40);
        }
        if (this.healthInd >= 28 && this.healthInd <= 30 && this.hunger < 90) {
            if (this.healthInd === 28) {
                this.hunger += random(35, 55);
                this.matchStamina += 40;
            }
            if (this.healthInd === 29 && this.strategy[3] < 0.3) {
                if (Math.random(1) < 0.2 + (0.01 * this.stamina)) {
                    this.hunger += random(2, 5);
                    this.matchStamina += 3;
                }
                else {
                    this.poisoned = true;
                }
            }
            if (this.healthInd === 30 && this.strategy[3] < 0.5) {
                if (Math.random(1) < 0.95 + (0.003 * this.stamina)) {
                    this.hunger += random(15, 20);
                    this.matchStamina += 18;
                }
                else {
                    this.poisoned = true;
                }
            }
        }
    }
    //if ((this.strategy[0] === 0) || (this.strategy[0] === 1 && (this.il >= 3 || matchtime > this.timelimit)) || (this.strategy[0] === 2 && (this.il >= 15 || matchtime > this.timelimit))) {
    //    this.gotToCenter = true;
    //}
    //if ((this.il > 3 && this.strategy[0] === 1) || (this.gotToCenter && this.strategy[0] === 2 || this.il >= 27)) {
        //this.goAwayFrom(300, 300);
        //this.goToLocation(300, 300);
    //}
    
    this.move();
    this.colColor = false;
    this.colColorVal = 0;
    this.colLake = false;
    this.colTCO = false;
    this.hittingtree = false;
    if (!validPoint(this.x, this.y)) {
        this.hittingtree = true;
    }
    if (random(0, 1) < 0.25 && this.weaponInd === "No Weapon") {
        this.maxvalue = 0;
        this.maxvalueind = "No Value";
        for (var i = 0 ; i < this.inventory.length ; i++) {
            if (this.inventory[i] !== "Empty Space") {
                if (weaponValues[itemList.indexOf(this.inventory[i])] > this.maxvalue) {
                    this.maxvalue = weaponValues[itemList.indexOf(this.inventory[i])];
                    this.maxvalueind = i;
                }
            }
        }
        if (this.maxvalueind !== "No Value") {
            this.weapon = this.inventory[this.maxvalueind];
            this.weaponInd = this.maxvalueind;
            this.weaponIcon = itemList.indexOf(this.inventory[this.maxvalueind]);
        }
    }
    this.tr = false;
    
    if (!validPoint(this.x, this.y)) {
            //this.x = this.treeprevx;
            //his.y = this.treeprevy;
        
    }
    /*this.weapon = "Mythical Dragon's Sword";
    this.weaponInd = 0;
    this.weaponIcon = 21;*/
};

AIPlayer.prototype.move = function() {
    if (dist(this.x, this.y, this.target[0], this.target[1]) < 10 || (frameCount % 40 === 0 && !this.turning) || this.colLake || (this.colColor && !this.colTCO) || dist(this.x, this.y, 300, 300) > borderDist / 2 - 200) {
        this.look();
    }
    if (matchtime > this.timelimit && !this.randomTarget) {
        //this.randomTarget = [cos(random(0, 360)) * 1200, sin(random(0, 360)) * 1200];
    }
    this.turning = false;
    if (!this.looting) {
        //stroke(0, 0, 0);
        //strokeWeight(10);
        //line(this.x, this.y, this.target[0], this.target[1]);
        this.ang = this.ang % 360;
        this.targetAng = Math.atan2(this.y - this.target[1], this.x - this.target[0]) * (180 / Math.PI);
        if (degreeDifference(this.ang, this.targetAng) < 10) {
            if (validPoint(this.x, this.y)) {
                this.x -= cos(this.ang) * ((this.speed / 2) + 3);
                this.y -= sin(this.ang) * ((this.speed / 2) + 3);
            }
            else {
                this.x -= cos(this.ang) * ((this.speed / 2) + 3) * 0.5;
                this.y -= sin(this.ang) * ((this.speed / 2) + 3) * 0.5;
            }
        }
        else {
            this.turning = true;
            if (degreeDifference(this.ang + 1, this.targetAng) < degreeDifference(this.ang - 1, this.targetAng)) {
                
                this.ang += 9;
            }
            else {
                this.ang -= 9;
            }
        }
    }
};

AIPlayer.prototype.look = function() {
    this.oldtarget = this.target;
    this.looting = false;
    this.minDist = 100000000;
    this.minInd = "No Players";
    this.avg = [0, 0];
    this.sameweapon = true;
    this.betterweapon = true;
    for (var i = 0 ; i < players.length ; i++) {
        if (players[i] !== this && players[i].x > this.x - 300 && players[i].x < this.x + 300 && players[i].y > this.y - 300 && players[i].y < this.y + 300) {
            if (dist(this.x, this.y, players[i].x, players[i].y) < this.minDist) {
                this.minDist = dist(this.x, this.y, players[i].x, players[i].y);
                this.avg[0] += players[i].x;
                this.avg[1] += players[i].y;
                this.minInd = i;
            }
            if (weaponValues[itemList.indexOf(this.weapon)] < weaponValues[itemList.indexOf(players[i].weapon)]) {
                this.betterweapon = false;
                this.sameweapon = false;
            }
            if (weaponValues[itemList.indexOf(this.weapon)] === weaponValues[itemList.indexOf(players[i].weapon)]) {
                this.betterweapon = false;
            }
        }
    }
    this.avg = [this.avg[0] / players.length, this.avg[1] / players.length];
    this.playerTarget = false;
    this.chestTarget = false;
    this.droppedTarget = false;
    this.collideTarget = false;
    this.borderTarget = false;
    if (dist(this.x, this.y, 300, 300) > borderDist / 2 - 200) {
        this.borderTarget = [300, 300];
    }
    if (this.colLake || (this.colColor && !this.colTCO)) {
        this.collideTarget = [this.x + sin(random(0, 360)) * 1200, this.y + sin(random(0, 360)) * 1200];
    }
    if (this.minInd !== "No Players") {
        if (this.strategy[1] === 2 || (this.strategy[1] === 1 && this.betterweapon)) {
            this.playerTarget = [players[this.minInd].x, players[this.minInd].y];
        }
        else if (this.strategy[1] === 0 || (this.strategy[1] === 1 && !this.sameweapon && !this.betterweapon)) {
            this.playerTarget = [this.x + (this.x - this.avg[0]), this.y + (this.y - this.avg[1])];
            this.panicFrame = 50;
        }
    }
    this.reset = true;
    if (this.chestInd !== "No Chest") {
        if (!this.looted[this.chestInd]) {
            this.reset = false;
        }
    }
    if (this.reset) {
        this.chestInd = "No Chest";
        for (var i = 0 ; i < chests.length ; i++) {
            if (chests[i].x > this.x - 300 && chests[i].x < this.x + 300 && chests[i].y > this.y - 300 && chests[i].y < this.y + 300 && !this.looted[i] && chests[i].tier >= this.strategy[7]) {
                this.chestInd = i;
            }
        }
    }
    /*if (this.strategy[0] === 0 || (this.strategy[0] === 1 && this.il >= 4) || (this.strategy[0] === 2 && this.il >= 27)) {
        //if (dist(chests[this.chestInd].x, chests[this.chestInd].y, 300, 300) < 1200 && (this.strategy[0] === 0)) {
        
        //}
        //if (this.matchstart) {
        this.chestTarget = [2 * this.x - 300, 2 * this.y - 300];
    }
    else if (this.chestInd === "No Chest") {
        this.chestTarget = [300, 300];
    }
    else {
        this.chestTarget = [chests[this.chestInd].x, chests[this.chestInd].y];
    }*/
    if (this.chestInd !== "No Chest") {
        if (!(this.strategy[0] === 0 || (this.strategy[0] === 1 && this.il >= 4) || (this.strategy[0] === 2 && (this.il >= 27 || matchtime > this.timelimit))) || ((this.strategy[0] || (this.strategy[0] === 1 && this.il >= 4)) && (matchtime > this.timelimit))) {
            this.chestTarget = [chests[this.chestInd].x, chests[this.chestInd].y];
        }
        else {
            if (this.strategy[0] === 0 || (this.strategy[0] === 1 && this.il >= 4) || (this.strategy[0] === 2 && (this.il >= 27 || matchtime > this.timelimit))) {
                //this.finalTarget = [2 * this.x - 300, 2 * this.y - 300];
            }
            else {
                //this.finalTarget = [300, 300];
            }
        }
    }
        if ((this.strategy[0] === 0 || (this.strategy[0] === 1 && (this.il >= 4 || matchtime > this.timelimit)) || (this.strategy[0] === 2 && (this.il >= 27 || matchtime > this.timelimit))) || matchtime > this.timelimit) {
            this.finalTarget = [2 * this.x - 300, 2 * this.y - 300];
        }
        else {
            this.finalTarget = [300, 300];
        }
        
    if (this.chestInd !== "No Chest") {
        if (this.x > chests[this.chestInd].x - 30 && this.x < chests[this.chestInd].x + 30 && this.y > chests[this.chestInd].y - 30 && this.y < chests[this.chestInd].y + 30 && frameCount % 7 === 0) {
            var m = 0;
            var found = false;
            while (m < chests[this.chestInd].items.length  && !found) {
                if (this.worthIt(chests[this.chestInd].items[m])) {
                    found = true;
                    
                    this.inventory[this.lastEmptySpace] = chests[this.chestInd].items[m];
                    chests[this.chestInd].items[m] = "Empty Space";
                    this.looting = true;
                }
                m++;
            }
            if (found) {
                this.looted[this.chestInd] = true;
            }
        }
    } 
    this.minDropDist = 1000000;
    this.minDropDistInd = 0;
    this.droppedInRange = [];
    this.found = false;
    this.rightOnDropped = false;
    for (var i = 0 ; i < droppedItems.length ; i++) {
        if (dist(this.x, this.y, droppedItems[i][1], droppedItems[i][2]) < 25) {
            this.droppedInRange.push(droppedItems[i]);
            if (droppedValues[droppedItems[i][0]] > this.strategy[8]) {
                this.rightOnDropped = true;
            }
        }
        if (droppedItems[i][1] > this.x - 300 && droppedItems[i][1] < this.x + 300 && droppedItems[i][2] > this.y - 300 && droppedItems[i][2] < this.y + 300) {
            if (dist(this.x, this.y, droppedItems[i][1], droppedItems[i][2]) < this.minDropDist && droppedValues[droppedItems[i][0]] > this.strategy[8]) {
                this.minDropDist = dist(this.x, this.y, droppedItems[i][1], droppedItems[i][2]);
                this.minDropDistInd = i;
                this.found = true;
            }
        }
    }
    if (this.found) {
        this.droppedTarget = [droppedItems[this.minDropDistInd][1], droppedItems[this.minDropDistInd][2]];
    }
    if (random(0, 3) < 1 && this.rightOnDropped) {
        for (var i = 0 ; i < this.droppedInRange.length ; i++) {
            this.inventory[this.lastEmptySpace] = itemList[this.droppedInRange[i][0]];
            droppedItems.splice(droppedItems.indexOf(this.droppedInRange[i]), 1);
        }
    }
    //this.finalTarget = this.path();
    stroke(0, 0, 0);
    strokeWeight(3);
    //line(this.x, this.y, this.finalTarget[0], this.finalTarget[1]);
    //for (var i = 0 ; i < this.droppedIt
    this.followingPath = false;
    /*if (!this.hittingtree && !this.playerTarget && !this.chestTarget && !this.droppedTarget) {
        this.followingPath = true;
        this.targang = Math.atan2(this.oldtarget[1] - this.y, this.oldtarget[0] - this.x) * (180 / Math.PI);
        this.target = [this.x + cos(this.targang) * (dist(this.x, this.y, this.oldtarget[0], this.oldtarget[1]) + 5), sin(this.targang) * (dist(this.x, this.y, this.oldtarget[0], this.oldtarget[1]) + 5)];
    }
    else if (this.hittingtree) {
        this.target = this.finalTarget;
    }*/
    if (this.strategy[6] === 0) {
        if (this.immediateGoing && frameCount > this.immediateCenter) {
            this.target = [300, 300];
        }
        else if (this.borderTarget) {
            this.target = this.borderTarget;
        }
        else if (this.collideTarget) {
            this.target = this.collideTarget;
        }
        else if (this.playerTarget && (matchtime < this.timelimit || matchtime > this.timelimit + 1500)) {
            this.target = this.playerTarget;
        }
        else if (this.chestTarget && matchtime < this.timelimit) {
            this.target = this.chestTarget;
        }
        /*else if (this.droppedTarget) {
            this.target = this.droppedTarget;
        }*/
        else {
            this.target = this.finalTarget;
            this.followingPath = true;
        }
    }
    else if (this.strategy[6] === 1) {
        if (this.immediateGoing && frameCount > this.immediateCenter) {
            this.target = [300, 300];
        }
        else if (this.borderTarget) {
            this.target = this.borderTarget;
        }
        else if (this.collideTarget) {
            this.target = this.collideTarget;
        }
        else if (this.chestTarget && matchtime < this.timelimit) {
            this.target = this.chestTarget;
        }
        else if (this.playerTarget && (matchtime < this.timelimit || matchtime > this.timelimit + 1500)) {
            this.target = this.playerTarget;
        }
        /*else if (this.droppedTarget) {
            this.target = this.droppedTarget;
        }*/
        else {
            this.target = this.finalTarget;
            this.followingPath = true;
        }
    }
        //}
    //this.target = [300, 300];
    
    //this.attacking = true;
    if (this.posArr.length  - 1 > frameCount - 100) {
        if (dist(this.x, this.y, this.posArr[frameCount - 100][0], this.posArr[frameCount - 100][1]) < 100) {
            this.stagnationFrame = 50;
            this.r = random(0, 360);
            this.target = [this.x + cos(this.r) * 2000, this.y + sin(this.r) * 2000];
            this.stagTarget = [this.x + cos(this.r) * 2000, this.y + sin(this.r) * 2000];
        }
    }
};

AIPlayer.prototype.path = function() {
    /*var goodang = round(random(0, 360));
    var orggoodang = goodang - 5;
    var found = false;
    while (goodang !== orggoodang && !found && goodang < orggoodang + 400) {
        if (validPoint(this.x + cos(goodang) * 200, this.y + sin(goodang) * 200) && validPoint(this.x + cos(goodang) * 200, this.y + sin(goodang) * 50) && validPoint(this.x + cos(goodang) * 200, this.y + sin(goodang) * 10) && ((this.strategy[0] === 0 && dist(this.x, this.y, 300, 300) < dist(this.x + cos(goodang) * 100, this.y + sin(goodang) * 100, 300, 300)) || (this.strategy[0] >= 1 && dist(this.x, this.y, 300, 300) > dist(this.x + cos(goodang) * 100, this.y + sin(goodang) * 100, 300, 300)))) {
            found = true;
        }
        goodang += 5;
    }
    var finalt;
    finalt = [this.x + cos(goodang) * 200, this.y + cos(goodang) * 200];
    this.centerang = Math.atan2(this.y - 300, this.x - 300) * (180 / Math.PI);
    this.centerdist = dist(this.x, this.y, 300, 300);
    return finalt;*/
    /*switch (mapSeed) {
        case 1:
            if (dist(this.x, this.y, 300, 300) < 1000) {
                finalt = [2 * this.x - 300, 2 * this.y - 300];
            }
            else if (dist(this.x, this.y, 300, 300) >= 1000 && dist(this.x, this.y, 300, 300) < 1200 && degreeDifference(Math.atan2(this.y - 300, this.x - 300) * (180 / Math.PI), (this.startPos - 1)* (360 / this.pig) - 90) > 10 && degreeDifference((Math.atan2(this.y - 300, this.x - 300) * (180 / Math.PI)) % 45, 0) > 5) {
                finalt = [300 + cos(Math.atan2(this.y - 300, this.x - 300) * (180 / Math.PI) + 5) * dist(this.x, this.y, 300, 300), 300 + sin(Math.atan2(this.y - 300, this.x - 300) * (180 / Math.PI) + 5) * dist(this.x, this.y, 300, 300)];
            }
            else if (degreeDifference(this.centerAng, 0) < 10  && this.centerdist < 1650) {
                finalt = [this.x + 100, this.y];
            }
            else if (degreeDifference(this.centerAng, 190) < 10  && this.centerdist < 1650) {
                finalt = [this.x - 100, this.y];
            }
            else if (dist(this.x, this.y, 3900, 300) < 2000 && (Math.atan2(this.y - 300, this.x - 3900) * (180 / Math.PI) > 0 || Math.atan2(this.y - 300, this.x - 3900) * (180 / Math.PI) < -95)) {
                finalt = [3900 + cos(Math.atan2(this.y - 300, this.x - 3900) * (180 / Math.PI) + 5) * dist(this.x, this.y, 3900, 300), 3900 + sin(Math.atan2(this.y - 300, this.x - 3900) * (180 / Math.PI) + 5) * dist(this.x, this.y, 3900, 300)];
            }
            else if (dist(this.x, this.y, -3300, 300) < 2000 && (Math.atan2(this.y - 300, this.x + 3300) * (180 / Math.PI) > 0 || Math.atan2(this.y - 300, this.x + 3300) * (180 / Math.PI) < -95)) {
                finalt = [-3300 + cos(Math.atan2(this.y - 300, this.x + 3300) * (180 / Math.PI) + 5) * dist(this.x, this.y, -3300, 300), 3900 + sin(Math.atan2(this.y - 300, this.x + 3300) * (180 / Math.PI) + 5) * dist(this.x, this.y, -3300, 300)];
            }
            //else if (dist(this.x, this.y, 3900, 300) < 2000 && degreeDifference(Math.atan2(this.y - 300, this.x - 3900) * (180 / Math.PI), 270) < 10) {
                
            /*else if (dist(this.x, this.y, 300, 300) >= 1000 && dist(this.x, this.y, 300, 300) < 3600 && (Math.atan2(this.y - 300, this.x - 300) * (180 / Math.PI)) % 180) {
                finalt = [300 + cos(Math.atan2(this.y - 300, this.x - 300) * (180 / Math.PI)) * (dist(this.x, this.y, 300, 300) + 200), 300 + sin(Math.atan2(this.y - 300, this.x - 300) * (180 / Math.PI)) * (dist(this.x, this.y, 300, 300) + 200)];
            }f
            else if ((degreeDifference(Math.atan2(this.y - 300, this.x - 300), 0) < 10 || degreeDifference(Math.atan2(this.y - 300, this.x - 300), 180) < 10) && dist(this.x, this.y, 300, 300) >= 1650) {
                
    }*/
};

AIPlayer.prototype.goAwayFrom = function(x, y) {
    if (!this.moved) {
        this.pos = new PVector(this.x, this.y);
        this.p1 = new PVector(x, y);
        this.pos.sub(this.p1);
        this.pos.normalize();
        this.pos.mult((this.speed / 2) + 3);
        this.x += this.pos.x;
        this.y += this.pos.y;
        this.moved = true;
    }
};

AIPlayer.prototype.flee = function() {
    var xs = 0;
    var ys = 0;
    for (var i = 0 ; i < this.playersSeen.length ; i++) {
        xs += this.playersSeen[i][0];
        ys += this.playersSeen[i][1];
    }
    xs /= this.playersSeen.length;
    ys /= this.playersSeen.length;
    this.goToLocation(300 - xs, 300 - ys);
};

AIPlayer.prototype.worthIt = function(item) {
    if (item === "Empty Space") {
        return false;
    }
    var iitem = item.split(" ");
    if (iitem[iitem.length - 1] === "Fang" && !this.risky) {
        return false;
    }
    var itemVal = trueitems[stritems.indexOf(item)][2];
    if (itemVal < this.tol) {
        return true;
    }
    else {
        return false;
    }
    return true;
};

AIPlayer.prototype.goToLocation = function(x, y) {
    if (!this.moved) {
        this.pos = new PVector(this.x, this.y);
        this.p1 = new PVector(x, y);
        this.pos.sub(this.p1);
        this.pos.normalize();
        this.pos.mult((this.speed / 2) + 3);
        this.x -= this.pos.x;
        this.y -= this.pos.y;
        this.moved = true;
    }
};

AIPlayer.prototype.stalkPlayer = function() {
    if (Player1.x < this.x + 300 && Player1.x > this.x - 300 && Player1.y < this.y + 300 && Player1.y < this.y + 300) {
        this.goToLocation(Player1.x, Player1.y);
    }
};

var items = [["Empty Bottle", 27, 2], ["Copper Sword", 20, 1], ["Silver Sword", 10, 1], ["Golden Sword", 6, 1], ["Majestic Platinum Sword", 3, 1], ["Mythical Dragon's Sword", 1, 1], ["0-25 Health Pack", 15, 2], ["25-50 Health Pack", 12, 2], ["50-99 Health Pack", 8, 2], ["Full Health Pack", 5, 2], ["Multi-use Health Pack", 4, 2], ["SC Potion", 18, 3], ["Polyjuice", 2, 3], /*["Teleporter", 1, 2], */["Sharktooth Fang", 5, 3], ["Snakeskin Fang", 5, 2], ["Bearjaw Fang", 5, 1], ["Beef Jerky", 15, 2], ["Nightlock", 20, 1], ["Red Berries", 20, 3]];
var trueitems = [["Empty Bottle", 27, 2], ["Copper Sword", 20, 1], ["Silver Sword", 10, 1], ["Golden Sword", 6, 1], ["Majestic Platinum Sword", 3, 1], ["Mythical Dragon's Sword", 1, 1], ["0-25 Health Pack", 15, 2], ["25-50 Health Pack", 12, 2], ["50-99 Health Pack", 8, 2], ["Full Health Pack", 5, 2], ["Multi-use Health Pack", 4, 2], ["Red Potion", 11, 3], ["Green Potion", 11, 3], ["Blue Potion", 11, 3], ["Yellow Potion", 11, 3], ["Purple Potion", 11, 3], ["Orange Potion", 11, 3], ["Polyjuice", 2, 3], /*["Teleporter", 1, 2], */["Sharktooth Fang", 5, 3], ["Snakeskin Fang", 5, 2], ["Bearjaw Fang", 5, 1], ["Beef Jerky", 15, 2], ["Nightlock", 20, 1], ["Red Berries", 20, 3]];
var stritems = [];
for (var i = 0 ; i < trueitems.length ; i++) {
    stritems.push(trueitems[i][0]);
}
var firstFind = function(r, arr) {
    var ind = 0;
    while (r < arr[ind][1]) {
        ind ++;
    }
    return ind;
};

var sumOfItems = function(ims) {
    var sumi = [];
    var tick = 0;
    for (var i = 0 ; i < ims.length ; i++) {
        sumi.push([ims[i][0], tick]);
        tick += ims[i][1];
    }
    return [sumi.reverse(), tick];
};

var getChestItems = function(c, t) {
    var newItems = [];
    for (var i = 0 ; i < items.length ; i++) {
        if (items[i][2] === c) {
            newItems.push([items[i][0], items[i][1] * 3, items[i][2]]);
        }
        else {
            newItems.push([items[i][0], items[i][1], items[i][2]]);
        }
    }
    var s = sumOfItems(newItems);
    var finalCount = s[1];
    var sumArray = s[0];
    var randNum = round(random(-0.4, finalCount + 0.4));
    var possibleItems = [];
    for (var i = 0 ; i < 1000 ; i ++) {
        randNum = round(random(-0.4, finalCount + 0.4));
        var cind = [items[firstFind(randNum, sumArray)][0], items[firstFind(randNum, sumArray)][1]];
        possibleItems.push(cind);
    }
    possibleItems.sort(function(a, b) { return a[1] - b[1]; });
    var itemCounts = 0;
    while (itemCounts < 4) {
        itemCounts = round(random(t * 5 - 7, t * 5 + 7));
    }
    var chestItems = [];
    for (var i = 0 ; i < itemCounts ; i++) {
        var pi;
        switch (t) {
            case 1:
                if (random(0, 25) < 1) {
                    pi = possibleItems;
                }
                else if (random(0, 5) < 1) {
                    pi = possibleItems.slice(499, 999);
                }
                else if (random(0, 2) < 1) {
                    pi = possibleItems.slice(799, 999);
                }
                else {
                    pi = possibleItems.slice(949, 999);
                }
                break;
            case 2:
                if (random(0, 16) < 1) {
                    pi = possibleItems;
                }
                else if (random(0, 3) < 1) {
                    pi = possibleItems.slice(499, 999);
                }
                else if (random(0, 1.8) < 1) {
                    pi = possibleItems.slice(799, 999);
                }
                else {
                    pi = possibleItems.slice(949, 999);
                }
                break;
            case 3:
                if (random(0, 12) < 1) {
                    pi = possibleItems;
                }
                else if (random(0, 2.5) < 1) {
                    pi = possibleItems.slice(499, 999);
                }
                else if (random(0, 1.5) < 1) {
                    pi = possibleItems.slice(799, 999);
                }
                else {
                    pi = possibleItems.slice(949, 999);
                }
                break;
            case 4:
                if (random(0, 8) < 1) {
                    pi = possibleItems;
                }
                else if (random(0, 2) < 1) {
                    pi = possibleItems.slice(499, 999);
                }
                else if (random(0, 1.3) < 1) {
                    pi = possibleItems.slice(799, 999);
                }
                else {
                    pi = possibleItems.slice(949, 999);
                }
                break;
            case 5:
                if (random(0, 4) < 1) {
                    pi = possibleItems;
                }
                else if (random(0, 1.5) < 1) {
                    pi = possibleItems.slice(499, 999);
                }
                else if (random(0, 1.1) < 1) {
                    pi = possibleItems.slice(799, 999);
                }
                else {
                    pi = possibleItems.slice(949, 999);
                }
                break;
        }
        var possibleInd = round(random(-0.4, pi.length - 0.6));
        chestItems.push(pi[possibleInd][0]);
    }
    var counts = [];
    for (var i = 0 ; i < items.length ; i++) {
        counts.push(0);
    }
    for (var i = 0 ; i < chestItems.length ; i++) {
        counts[stritems.indexOf(chestItems[i])] ++;
    }
    for (var i = 0 ; i < counts.length ; i++) {
        while (counts[i] > 3) {
            chestItems.splice(chestItems.indexOf(stritems[i]), 1);
            counts[i] --;
        }
    }
    while (chestItems.length < t * 12) {
        chestItems.splice(round(random(-0.4, chestItems.length - 0.6)), 0, "Empty Space");
    }
    return chestItems;
};

var drawStar = function(x, y, r) {
    noStroke();
    fill(224, 216, 110);
    beginShape();
    for (var i = -90 ; i < 270 ; i += 72) {
        vertex(x + cos(i) * (r / 2), y + sin(i) * (r / 2));
        vertex(x + cos(i + 36) * (r / 5), y + sin(i + 36) * (r / 5));
    }
    endShape();
};


var chests = [];
var droppedItems = [];
var chestItems = [];
var dispChestInd = 0;

var colorWords = ["White", "Red", "Green", "Blue", "Yellow", "Purple", "Orange"];
var itemList;

var Chest = function(tier, c, x, y) {
    
    this.clas = c; //Misspelled on purpose, because "class" is reserved
    this.mythical = false;
    this.displayed = false;
    this.tier = tier;
    this.itemCount = 0;
    this.chestSize = 12 * this.tier;
    this.items = getChestItems(this.clas, this.tier);
    
    this.x = x;
    this.y = y;
    this.mythical = false;
    for (var i = 0 ; i < this.items.length ; i++) {
        if (this.items[i] === "SC Potion") {
            this.items[i] = colorWords[round(random(0.6, colorNum + 0.4))] + " Potion";
        }
        if (itemList.indexOf(this.items[i]) >= 20) {
            this.mythical = true;
        }
    }
};

Chest.prototype.update = function() {
    fill(214, 177, 102);
    stroke(0, 0, 0);
    strokeWeight(3);
    rect(this.x, this.y, 60, 60, 2);
    noStroke();
    for (var i = 0 ; i < this.tier ; i++) {
        drawStar(this.x + ((i + 0.5) - this.tier / 2) * 10, this.y + 20, 10);
    }
    switch (this.clas) {
        case 1:
            image(imgs.chest1, this.x - 30, this.y - 30);
            break;
        case 2:
            image(imgs.chest2, this.x - 30, this.y - 30);
            break;
        case 3:
            image(imgs.chest3, this.x - 30, this.y - 30);
            break;
        case 4:
            image(imgs.chest4, this.x - 30, this.y - 30);
    }
    
    if (dist(this.x, this.y, Player1.x, Player1.y) < 50 && countdown <= 0) {
        resetMatrix();
        fill(0, 0, 0);
        textSize(25);
        textFont(createFont("Avenir"));
        text("Press ENTER or \"X\" to open chest.", 300, 300);
        textFont(createFont("AvenirNext-UltraLight"));
        if ((keys[10] || keys[88]) && !this.displayed) {
            this.displayed = true;
            displayed = true;
        }
        translate(300, 300);
        rotate(Player1.ang);
        translate(-300, -300);
        translate(300 - Player1.x, 300 - Player1.y);
    }
    
    if (this.displayed) {
        chestItems = this.items;
        dispChestInd = chests.indexOf(this);
    }
};

chests = [];
droppedItems = [];

var playerOptions = [12, 18, 24, 36, 48, "Random"];
var oldpn = 2 + playerOptions.length * 1000;

var colorOptions = [2, 3, 4, 6, "Random"];
var oldcn = 1 + colorOptions.length * 1000;

var textPositions = [];
textPositions[12] = 573;
textPositions[18] = 578;
textPositions[24] = 582;
textPositions[36] = 585;
textPositions[48] = 585;

var jumpers = [];
var thr = 560;
for (var i = 0 ; i < 5 ; i++) {
    jumpers.push([random(-200, 800), thr, 0, round(random(0, 1)) * 2 - 1, random(2, 4), random(20, 60), false, 0, 0, 0]);
}

var colorBackground = function() {
    image(imgs.bcg3, 0, 0);
    fill(255, 255, 255);
    stroke(0, 0, 0);
    strokeWeight(2);
    for (var i = 0 ; i < jumpers.length ; i++) {
        jumpers[i][8] = jumpers[i][0];
        jumpers[i][9] = jumpers[i][1];
        if (jumpers[i][0] < -200) {
            jumpers[i][0] = 800;
        }
        if (jumpers[i][0] > 800) {
            jumpers[i][0] = -200;
        }
        jumpers[i][1] += jumpers[i][2];
        jumpers[i][2] += 0.35;
        if (jumpers[i][1] > thr) {
            jumpers[i][6] = false;
            jumpers[i][1] = thr;
            jumpers[i][2] = 0;
        }
        if (!jumpers[i][6] && frameCount > jumpers[i][7] + jumpers[i][5]) {
            jumpers[i][6] = true;
            jumpers[i][2] = -8;
            jumpers[i][7] = frameCount;
            jumpers[i][5] = random(50, 160);
        }
        jumpers[i][0] += jumpers[i][3] * jumpers[i][4];
        fill(255, 255, 255);
        ellipse(jumpers[i][0], jumpers[i][1], 30, 30);
        fill(0, 0, 0);
        ellipse(jumpers[i][0] - 5, jumpers[i][1] - 5, 2, 2);
        ellipse(jumpers[i][0] + 5, jumpers[i][1] - 5, 2, 2);
        for (var j = 0 ; j < jumpers.length ; j++) {
            if (dist(jumpers[i][0], jumpers[i][1], jumpers[j][0], jumpers[j][1]) < 30 && j !== i) {
                jumpers[i][3] *= -1;
                jumpers[j][3] *= -1;
            }
        }
    }
    //background(255, 255, 255);
    fill(255, 0, 0, 80);
    noStroke();
    ellipse(0, 300, 700, 700);
    fill(0, 255, 0, 80);
    ellipse(300, 0, 700, 700);
    fill(0, 0, 255, 80);
    ellipse(600, 300, 700, 700);
    fill(255, 255, 0, 80);
    ellipse(300, 600, 700, 700);
    fill(255, 255, 255, 155);
    rect(300, 300, 600, 600);
    fill(64, 133, 8, 150);
    if (newscene === "Achievements" || newscene === "Final" || newscene === "ChooseAttributes" || newscene === "Shop") {
        textSize(16);
        text("You currently have " + money + "$", 500, 10);
    }
};



var trees = [];

var mapNames = ["Forests and Lakes", "Dark Forest", "Plains", "Lakes, Forests,\nand Plains", "Island"];
var mapSizes = ["Medium", "Large", "Small", "Medium", "Large"];

var mapSeed;
var defaultColor;
var pathColor;
var mapSize;
var colorZones = [];
var lakes = [];
var grass = [];
var i, j, k, l, m, n;
var rad = Math.pow(10, 8);
var arcLine = function(cpx, cpy, ang) {
    return [cpx + rad * cos(ang), cpy + rad * sin(ang)];
};
var centerPoint = function(x1, y1, x2, y2) {
    return [(x1 + x2) / 2, (y1 + y2) / 2];
};
var lineToArc = function(x1, y1, x2, y2) {
    var cp = centerPoint(x1, y1, x2, y2);
    var ang = atan2(y2 - y1, x2 - x1);
    var al = [cp, ang - 90, dist(x1, y1, x2, y2) / 2];
    var ax = arcLine(al[0][0], al[0][1], al[1]);
    return ["Arc", ax[0], ax[1], rad - 100, rad + 100, al[0][0], al[0][1], al[2]];
};

var realms = [];

var beaches = [];

var LoadMap = function() {
    lakes = [];
    paths = [];
    grass = [];
    trees = [];
    realms = [];
    beaches = [];
    switch (mapSeed) {
        case 1:
            realms.push(["Forest", -7500, -7500, 15000, 15000]);
            mapSize = 15000;
            spfac = 1100;
            trees.push([300, 300]);
            paths.push(["Ellipse", 0, 0, 1200]);
            paths.push(lineToArc(0, -1200, 0, -4800));
            paths.push(lineToArc(0, 1200, 0, 4800));
            for (var i = 45 ; i < 395 ; i += 90) {
                paths.push(lineToArc(cos(i) * 1200, sin(i) * 1200, cos(i) * 3600, sin(i) * 3600));
                paths.push(["Ellipse", cos(i) * 3600, sin(i) * 3600, 150]);
                chests.push(new Chest(2, (i - 45) / 90 + 1, cos(i) * 3600, sin(i) * 3600));
            }
            chests.push(new Chest(3, round(random(0.6, 4.4)), 0, -5000));
            chests.push(new Chest(3, round(random(0.6, 4.4)), 0, 5000));
            for (var i = -180 ; i <= 0 ; i += 36) {
                paths.push(lineToArc(0, -4800, cos(i) * 1800, -4800 + sin(i) * 1800));
                colorZones.push([cos(i) * 1800, -4800 + sin(i) * 1800, 1800, (i - (-180)) / 36]);
                chests.push(new Chest(3, round(random(0.6, 4.4)), cos(i) * 1800, -4800 + sin(i) * 1800));
                paths.push(lineToArc(0, 4800, cos(-180 - (i - 180)) * 1800, 4800 + sin(-180 - (i - 180)) * 1800));
                colorZones.push([cos(-180 - (i - 180)) * 1800, 4800 + sin(-180 - (i - 180)) * 1800, 1800, (i - (-180)) / 36]);
                chests.push(new Chest(3, round(random(0.6, 4.4)), cos(-180 - (i - 180)) * 1800, 4800 + sin(-180 - (i - 180)) * 1800));
            }
            paths.push(["Arc", 0, -4800, 1700, 1900]);
            paths.push(["Arc", 0, 4800, 1700, 1900]);
            paths.push(["Arc", 0, 0, 3500, 3700]);
            paths.push(lineToArc(1200, 0, 1800, 0));
            paths.push(lineToArc(-1200, 0, -1800, 0));
            paths.push(["Ellipse", 3600, 0, 1800]);
            paths.push(["Ellipse", -3600, 0, 1800]);
            lakes.push([3600, 0, 3300]);
            lakes.push([-3600, 0, 3300]);
            for (var i = 0 ; i < 360 ; i += 90) {
                chests.push(new Chest(5, i / 90 + 1, cos(i) * 100, sin(i) * 100));
            }
            for (var i = 0 ; i < 360 ; i += 60) {
                chests.push(new Chest(4, (i % 120) / 30 + 1, cos(i) * 300, sin(i) * 300));
            }
            for (var i = 0 ; i < 360 ; i += 40) {
                chests.push(new Chest(3, (i % 80) / 20 + 1, cos(i) * 500, sin(i) * 500));
            }
            for (var i = 0 ; i < 360 ; i += 30) {
                chests.push(new Chest(2, (i % 60) / 15 + 1, cos(i) * 700, sin(i) * 700));
            }
            break;
        case 2:
            mapSize = 40000;
            spfac = 2400;
            realms.push(["Forest", -20000, -20000, 40000, 40000]);
            var arcx, arcy, ax;
            for (var i = -90 ; i < 270 ; i += 360 / 24) {
                paths.push(["Ellipse", cos(i) * 2400, sin(i) * 2400, 150]);
                if (i % 30 !== 0) {
                    paths.push(lineToArc(cos(i) * 7200, sin(i) * 7200, cos(i) * 18000, sin(i) * 18000));
                    lakes.push([cos(i) * 19000, sin(i) * 19000, 2000]);
                    paths.push(["Ellipse", cos(i) * 19000, sin(i) * 19000, 1300]);
                }
                paths.push(["Ellipse", cos(i) * 10200, sin(i) * 10200, 200]);
                chests.push(new Chest(1, round(random(0.6, 4.4)), cos(i) * 10200, sin(i) * 10200));
                paths.push(["Ellipse", cos(i) * 7200, sin(i) * 7200, 200]);
                chests.push(new Chest(2, round(random(0.6, 4.4)), cos(i) * 7200, sin(i) * 7200));
                if (i % 30 === 0) {
                    chests.push(new Chest(3, round(random(0.6, 4.4)), cos(i) * 16800, sin(i) * 16800));
                }
                //paths.push(["Line", 0, 0, cos(i) * 2400, sin(i) * 2400, 200]);
                arcx = 0;
                arcy = 0;
                ax = arcLine(arcx, arcy, i);
                if (i % 30 !== 0 && i < 90) {
                    paths.push(lineToArc(-cos(i) * 2400, -sin(i) * 2400, cos(i) * 2400, sin(i) * 2400));
                }
                else if (i % 30 === 0) {
                    if (i < 90) {
                        paths.push(lineToArc(-cos(i) * 21600, -sin(i) * 21600, cos(i) * 21600, sin(i) * 21600));
                    }
                    paths.push(lineToArc(cos(i - 360 / 24) * 2400, sin(i - 360 / 24) * 2400, cos(i) * 7200, sin(i) * 7200));
                    paths.push(lineToArc(cos(i + 360 / 24) * 2400, sin(i + 360 / 24) * 2400, cos(i) * 7200, sin(i) * 7200));
                    colorZones.push([cos(i) * 16800, sin(i) * 16800, 7200, ((i - (-90)) / (360 / 12)) % 6]);
                    
                }
            }
            paths.push(["Arc", 0, 0, 2320, 2480]);
            paths.push(["Ellipse", 0, 0, 300]);
            paths.push(["Arc", 0, 0, 16700, 16900]);
            paths.push(["Arc", 0, 0, 7100, 7300]);
            paths.push(["Arc", 0, 0, 12900, 13100]);
            //paths.push(["Arc", 1200, rad, rad - 100, rad + 100, 1200, 0, 2400]);
            //paths.push(["Arc", cos(30) * Math.pow(10, 9), sin(30) * Math.pow(10, 9), Math.pow(10, 9) - 100, Math.pow(10, 9) + 100, 0, 0, 2400]);
            for (var j = 0  ; j < 360 ; j += 30) {
                chests.push(new Chest(2 + 2*(j % 60) / 60, (j % 120) / 30 + 1, cos(j) * 600, sin(j) * 600));
            }
            for (var k = 0 ; k < 360 ; k += 60) {
                chests.push(new Chest(4, (k % 240) / 60 + 1, cos(k) * 200, sin(k) * 200));
            }     
            chests.push(new Chest(5, 4, 0, 0));
            
            break;
        case 3:
            spfac = 800;
            mapSize = 4800;
            realms.push(["Plains", -2400, -2400, 4800, 4800]);
            for (var i = 0 ; i <= 180 ; i += 36) {
                colorZones.push([cos(i) * 1500, sin(i) * 1500, 600, i / 36]);
                chests.push(new Chest(3, round(random(0.6, 4.4)), cos(i) * 1500, sin(i) * 1500));
            }
            for (var i = 210 ; i < 360 ; i += 30) {
                grass.push([cos(i) * 1500, sin(i) * 1500, 600]);
            }
            lakes.push([0, 0, 600]);
            for (var i = 0 ; i < 360 ; i += 15) {
                chests.push(new Chest(round(random(0.6, 5.4)), round(random(0.6, 4.4)), cos(i) * 400, sin(i) * 400));
            }
            break;
        case 4:
            spfac = 1000;
            mapSize = 24000;
            realms.push(["Forest", -10000, 0, 10000, 10000]);
            realms.push(["Forest", 0, -10000, 10000, 20000]);
            realms.push(["Plains", -10000, -10000, 10000, 10000]);
            paths.push(["Ellipse", 0, 0, 1200, true]);
            for (var i = -90 ; i < 180 ; i += 22.5) { 
                paths.push(lineToArc(0, 0, cos(i) * 9000, sin(i) * 9000));
                paths.push(["Arc", cos(i) * 8000, sin(i) * 8000, 900, 1100]);
                paths.push(["Ellipse", cos(i) * 8000, sin(i) * 8000, 300]);
                lakes.push([cos(i) * 8000, sin(i) * 8000, 400]);
            }
            paths.push(["Ellipse", -5000, 5000, 4000]);
            lakes.push([-5000, 5000, 7800]);
            paths.push(["Arc", 0, 0, 1900, 2100]);
            paths.push(["Arc", 0, 0, 3900, 4100]);
            paths.push(["Arc", 0, 0, 5900, 6100]);
            paths.push(["Arc", 0, 0, 7900, 8100]);
            chests.push(new Chest(5, round(random(0.6, 4.4)), 0, 0));
            for (var i = 0 ; i < 360 ; i += 120) {
                chests.push(new Chest(4, round(random(0.6, 4.4)), cos(i) * 200, sin(i) * 200));
            }
            for (var i = 0 ; i < 360 ; i += 60) {
                chests.push(new Chest(3, round(random(0.6, 4.4)), cos(i) * 400, sin(i) * 400));
            }
            for (var i = 0 ; i < 360 ; i += 40) {
                chests.push(new Chest(2, round(random(0.6, 4.4)), cos(i) * 600, sin(i) * 600));
            }
            for (var i = 0 ; i < 360 ; i += 30) {
                chests.push(new Chest(1, round(random(0.6, 4.4)), cos(i) * 800, sin(i) * 800));
            }
            for (var i = 180 ; i < 270 ; i += 15) {
                grass.push([cos(i) * 2000, sin(i) * 2000, 300]);
                colorZones.push([cos(i) * 4000, sin(i) * 4000, 800, (i - 180) / 15]);
                chests.push(new Chest(round(random(0.6, 3.4)), round(random(0.6, 4.4)), cos(i) * 4000, sin(i) * 4000));
                colorZones.push([cos(i) * 7000, sin(i) * 7000, 1800, (i - 180) / 15]);
                //if (i % 60 === 0) {
                chests.push(new Chest(round(random(1.6, 4.4)), round(random(0.6, 4.4)), cos(i) * 7000, sin(i) * 7000));
            }
            paths.push(["Ellipse", -7000, 0, 300]);
            break;
        case 5:
            spfac = 1000;
            mapSize = 36000;
            realms.push(["Forest", -18000, -18000, 36000, 36000]);
            lakes.push([0, 0, 10000, 2800, 360 / 24]);
            paths.push(["Ellipse", 0, 0, 1400, true]);
            paths.push(["Arc", 0, 0, 1400, 5600]);
            beaches.push([0, 0, 1200, 1400]);
            beaches.push([0, 0, 5000, 5200]);
            paths.push(["Arc", 0, 0, 5200, 5400]);
            for (var i = 0 ; i < 360 ; i += (360 / players.length)) {
                boats.push(new Boat(cos(i) * 1430, sin(i) * 1430, i + 90));
            }
            for (var i = 0 ; i < 360 ; i += 360 / 48) {
                paths.push(lineToArc(cos(i) * 5200, sin(i) * 5200, cos(i) * 6500, sin(i) * 6500));
                paths.push(["Ellipse", cos(i) * 6500, sin(i) * 6500, 150]);
            }
            paths.push(["Arc", 0, 0, 6400, 6600]);
            for (var i = 0 ; i < 360 ; i += 360 / 24) {
                paths.push(lineToArc(cos(i) * 6500, sin(i) * 6500, cos(i) * 8500, sin(i) * 8500));
                colorZones.push([cos(i) * 7500, sin(i) * 7500, 1800, (i / (360 / 24)) % 6]);
                paths.push(["Ellipse", cos(i) * 7500, sin(i) * 7500, 250]);
            }
            paths.push(["Arc", 0, 0, 7400, 7600]);
            for (var i = 0 ; i < 360 ; i += 120) {
                chests.push(new Chest(5, round(random(0.6, 4.4)), cos(i) * 200, sin(i) * 200));
            }
            for (var i = 0 ; i < 360 ; i += 40) {
                chests.push(new Chest(4, round(random(0.6, 4.4)), cos(i) * 400, sin(i) * 400));
            }
            for (var i = 0 ; i < 360 ; i += 40) {
                chests.push(new Chest(3, round(random(0.6, 4.4)), cos(i) * 600, sin(i) * 600));
            }
            for (var i = 0 ; i < 360 ; i += 36) {
                chests.push(new Chest(2, round(random(0.6, 4.4)), cos(i) * 800, sin(i) * 800));
            }
            for (var i = 0 ; i < 360 ; i += 360 / 48) {
                chests.push(new Chest(round(random(0.6, 2.4)), round(random(0.6, 4.4)), cos(i) * 6500, sin(i) * 6500));
            }
            for (var i = 0 ; i < 360 ; i += 360 / 24) {
                chests.push(new Chest(round(random(2.6, 4.4)), round(random(0.6, 4.4)), cos(i) * 7500, sin(i) * 7500));
            }
            /*var ar;
            for (var i = 0 ; i < 360 ; i += 360 / 72) {
                ar = lineToArc(cos(i) * 1400, sin(i) * 1400, cos(i) * 5000, sin(i) * 5000);
                ar.push(true);
                paths.push(ar);
            }*/
            break;
        case 6:
            realms.push(["Forest", -18000, -18000, 36000, 36000]);
            paths.push(lineToArc(80, 150, 80, -2000));
            paths.push(lineToArc(-80, 150, -80, -2000));
            chests.push(new Chest(3, 3, 0, -750));
            break;
    }
    for (var i = 0 ; i < chests.length ; i++) {
        chests[i].x += 300;
        chests[i].y += 300;
    }
    for (var i = 0 ; i < boats.length ; i++) {
        boats[i].x += 300;
        boats[i].y += 300;
    }
    trees.push([300, 300]);
    for (var i = 0 ; i < lakes.length ; i++) {
        lakes[i][0] += 300;
        lakes[i][1] += 300;
    }
    for (var i = 0 ; i < paths.length ; i++) {
        paths[i][1] += 300;
        paths[i][2] += 300;
        if (paths[i][0] === "Line") {
            paths[i][3] += 300;
            paths[i][4] += 300;
        }
        if (paths[i][0] === "Arc" && paths[i][7]) {
            paths[i][5] += 300;
            paths[i][6] += 300;
        }
    }
    for (var i = 0 ; i < colorZones.length ; i++) {
        colorZones[i][0] += 300;
        colorZones[i][1] += 300;
    }
    for (var i = 0 ; i < grass.length ; i++) {
        grass[i][0] += 300;
        grass[i][1] += 300;
    }
    for (var i = 0 ; i < realms.length ; i++) {
        realms[i][1] += 300;
        realms[i][2] += 300;
    }
    for (var i = 0 ; i < beaches.length ; i++) {
        beaches[i][0] += 300;
        beaches[i][1] += 300;
    }
    for (var i = 0 ; i < players.length ; i++) {
        players[i].x = 300 + spfac * cos((360 / players.length) * i - 90);
        players[i].y = 300 + spfac * sin((360 / players.length) * i - 90);
        players[i].target = [players[i].x, players[i].y];
    }
};

var SetColors = function(c) {
    for (var i = 0 ; i < colorZones.length ; i++) {
        colorZones[i][3] = i % c;
    }
};

var drawTree;

var getAngle = function(x, y, ox, oy) {
    var tanAngle = Math.atan((y - oy) / (x - ox)) * (180 / Math.PI);
    if (x < ox) {
        tanAngle += 180;
    }
    return tanAngle;
};

var ing = false;

var DrawMap = function(s, t) {
    trees = [];
    var incr = 60;
    var fr = 0;
    
    if (s) {
        incr = 250;
        for (var i = -mapSize / 2 ; i < mapSize / 2 ; i += incr) {
            fr = 0;
            for (var j = -mapSize / 2 ; j < mapSize / 2 ; j += incr) {
                drawTree = true;
                //var x = Player1.x + i;
                //var y = Player1.y + j;
                var x = i + (((j - (-mapSize / 2)) / incr) % 2) * (incr / 2);
                var y = j;
                for (var k = 0 ; k < paths.length ; k++) {
                    if (paths[k][0] === "Ellipse") {
                        if (dist(x + 50, y + 50, paths[k][1], paths[k][2]) < paths[k][3] + 50) {
                            drawTree = false;
                        }
                    }
                    if (paths[k][0] === "Arc") {
                        if (dist(x + 50, y + 50, paths[k][1], paths[k][2]) > paths[k][3] && dist(x + 50, y + 50, paths[k][1], paths[k][2]) < paths[k][4]) {
                            if (!paths[k][7] || dist(x, y, paths[k][5], paths[k][6]) <= paths[k][7]) {
                                drawTree = false;
                            }
                        }
                    }
                    if (paths[k][0] === "Line") {
                        if (dist(x + 50, y + 50, paths[k][1], paths[k][2]) > paths[k][3] && dist(x + 50, y + 50, paths[k][1], paths[k][2]) < paths[k][4] && x > paths[k][5] && y > paths[k][6] && x < paths[k][7] && y < paths[k][8]) {
                            drawTree = false;
                        }
                    }
                }
                if (drawTree) {
                    trees.push([x, y]);
                }
                fr ++;
            }
        }
        
        for (var i = 0 ; i < trees.length ; i++) {
            fill(0, 125, 0);
            ellipse(trees[i][0], trees[i][1], 60, 60);
            image(imgs.tree, trees[i][0], trees[i][1]);
        }
        /*for (var i = 0 ; i < paths.length ; i++) {
            if (paths[i][0] === "Arc") {
                stroke(0, 0, 255, 50);
                noFill();
                strokeWeight(Math.abs(paths[i][4] - paths[i][3]));
                ellipse(paths[i][1], paths[i][2], (paths[i][3] + paths[i][4]), (paths[i][3] + paths[i][4]));
            }
            if (paths[i][0] === "Ellipse") {
                noStroke();
                fill(0, 0, 255, 50);
                ellipse(paths[i][1], paths[i][2], paths[i][3], paths[i][4]);
            }
        }*/
        noStroke();
    }
    
    var incr = 60;
    var fr = 0;
    var inf = 600;
    if (t) {
        inf = 3600;
    }
    for (var l = 0 ; l < realms.length ; l++) {
        switch (realms[l][0]) {
            case "Forest":
                if (Player1.moving) {
                    var newpaths = [];
                    for (var i = 0 ; i < paths.length ; i++) {
                        if (paths[i][0] === "Ellipse") {
                            if (dist(Player1.x, Player1.y, paths[i][1], paths[i][2]) < inf + paths[i][3]) {
                                newpaths.push(paths[i]);
                            }
                        }
                        if (paths[i][0] === "Arc") {
                            if (dist(paths[i][1], paths[i][2], Player1.x, Player1.y) > paths[i][3] - (inf - 100) && dist(paths[i][1], paths[i][2], Player1.x, Player1.y) < paths[i][4] + (inf - 100)) {
                                if (!paths[i][7] || dist(Player1.x, Player1.y, paths[i][5], paths[i][6]) <= paths[i][7] + (inf - 100)) {
                                    newpaths.push(paths[i]);
                                }
                            }
                        }
                    }
                    //newpaths = paths;
                    //trees = [];
                    for (var i = -inf - Player1.x % (incr * 2); i < inf ; i += incr) {
                        fr = 0;
                        for (var j = -inf - Player1.y % (incr * 2); j < inf ; j += incr) {
                            drawTree = true;
                            var x = Player1.x + i;
                            var y = Player1.y + j;
                            if (x < realms[l][1] - 50 || x > realms[l][1] + realms[l][3] - 50 || y < realms[l][2] - 50 || y > realms[l][2] + realms[l][4] - 50) {
                                drawTree = false;
                            }
                            for (var k = 0 ; k < newpaths.length ; k++) {
                                if (newpaths[k][0] === "Ellipse") {
                                    if (dist(x + 50, y + 50, newpaths[k][1], newpaths[k][2]) < newpaths[k][3] + 50) {
                                        drawTree = false;
                                    }
                                }
                                if (newpaths[k][0] === "Arc") {
                                    if (dist(x + 50, y + 50, newpaths[k][1], newpaths[k][2]) > newpaths[k][3] && dist(x + 50, y + 50, newpaths[k][1], newpaths[k][2]) < newpaths[k][4]) {
                                        if (!newpaths[k][7] || dist(x, y, newpaths[k][5], newpaths[k][6]) <= newpaths[k][7]) {
                                            drawTree = false;
                                        }
                                    }
                                }
                                if (newpaths[k][0] === "Line") {
                                    if (dist(x + 50, y + 50, newpaths[k][1], newpaths[k][2]) > newpaths[k][3] && dist(x + 50, y + 50, newpaths[k][1], newpaths[k][2]) < newpaths[k][4] && x > newpaths[k][5] && y > newpaths[k][6] && x < newpaths[k][7] && y < newpaths[k][8]) {
                                        drawTree = false;
                                    }
                                }
                            }
                            if (drawTree) {
                                if (fr % 2 === 0) {
                                    trees.push([x, y]);
                                    
                                }
                                else {
                                    trees.push([Player1.x + i + incr / 2, Player1.y + j]);
                                }
                            }
                            fr ++;
                        }
                    }
                    break;
                }
                else {
                    trees = oldtrees;
                }
            break;
            case "Plains":
                rectMode(LEFT);
                fill(102, 214, 102);
                rect(realms[l][1], realms[l][2], realms[l][3], realms[l][4]);
                fill(255, 255, 255, 100);
                //rect(realms[l][1], realms[l][2], realms[l][3], realms[l][4]);
                if (Player1.moving) {
                    for (var i = realms[l][1] ; i < realms[l][1] + realms[l][3] ; i += 600) {
                        for (var j = realms[l][2] ; j < realms[l][2] + realms[l][4] ; j += 600) {
                            trees.push([i, j]);
                        }
                    }
                }
                else {
                    trees = oldtrees;
                }
                rectMode(CENTER);
                break;
        }
        
    }
    oldtrees = trees;
    validTrees = [];
    //var coord = generateNoisePos(Player1.x, Player1.y, 300);
    noStroke();
    fill(102, 214, 102);
    for (var i = 0 ; i < realms.length ; i++) {
        if (realms[i][0] === "Plains") {
            rect(realms[i][1] - realms[i][3] / 4, realms[i][2] - realms[i][3] / 4, realms[i][3] / 2, realms[i][3] / 2);
        }
    }
    fill(0, 0, 0, 100);
    rect(0, 0, 100000, 100000);
    fill(255, 255, 255);
    if (mapSeed === 3) {
        fill(102, 214, 102);
    }
    stroke(255, 0, 0);
    strokeWeight(30);
    ellipse(300, 300, borderDist, borderDist);
    if (mapSeed === 4) {
        fill(102, 214, 102);
        arc(300, 300, borderDist, borderDist, 180, 270);
    }
    for (var i = 0 ; i < realms.length ; i++) {
        if (realms[i][0] === "Plains") {
            fill(102, 214, 102);
            arc(realms[i][1], realms[i][2], Math.min(realms[i][3], borderDist), Math.min(realms[i][3], borderDist), realms[i][4], realms[i][5]);
        }
    }
    
    noStroke();
    
    fill(102, 214, 102);
    //arc(300, 300, 100000, 100000, 180, 270);
    /*for (var i = 0 ; i < paths.length ; i++) {
        if (paths[i][0] === "Ellipse") {
            fill(0, 0, 255, 50);
            noStroke();
            ellipse(paths[i][1], paths[i][2], paths[i][3], paths[i][3]);
        }
        if (paths[i][0] === "Arc") {
            strokeWeight(paths[i][4] - paths[i][3] - 10);
            stroke(0, 0, 255, 50);
            noFill();
            arc(paths[i][1], paths[i][2], (paths[i][4] + paths[i][3]), (paths[i][4] + paths[i][3]), 0, 360);
        }
    }*/
    //for (var i = 0 ; i < coord.length ; i++) {
        //image(imgs.noisyDirt, coord[i][0], coord[i][1]);
        //image(imgs.noisyDirt, coord[i][0] - 300, coord[i][1] - 300);
    //}
    //background(82, 52, 8);
    /*for (var i = Player1.x - 300 ; i < Player1.x + 300 ; i += 120) {
        for (var j = Player1.y - 300 ; j < Player1.y + 300 ; j += 120) {
            
            fill(138, 96, 62);
            noStroke();
            ellipse(i, j, 80, 80);
            ellipse(i + 60, j + 60, 40, 40);
        }
    }*/
    for (var i = 0 ; i < trees.length ; i++) {
        if ((trees[i][0] > Player1.x - 600 && trees[i][0] < Player1.x + 600 && trees[i][1] > Player1.y - 600 && trees[i][1] < Player1.y + 600) || t) {
            validTrees.push(trees[i]);
            fill(140, 120, 100, 205);
            noStroke();
            rect(trees[i][0] + 30, trees[i][1] + 30, 60.5, 60.5);
            image(imgs.tree, trees[i][0], trees[i][1]);
        } 
    }
    for (var i = 0 ; i < lakes.length ; i++) {
        fill(45, 62, 168, 200);
        noStroke();
        ellipse(lakes[i][0], lakes[i][1], lakes[i][2], lakes[i][2]);
        if (lakes[i][4]) {
            noFill();
            strokeCap(SQUARE);
            stroke(255, 255, 255);
            strokeWeight(lakes[i][2] / 2);
            for (var j = 0 ; j < 360 ; j += lakes[i][4]) {
                arc(300, 300, (lakes[i][2] / 2), (lakes[i][2] / 2), j - 2.5, j + 3.3);
            }
            strokeWeight(1);
        }
    }
    for (var i = 0 ; i < paths.length ; i++) {
        if (paths[i][0] === "Ellipse" && paths[i][4]) {
            fill(255, 255, 255);
            ellipse(paths[i][1], paths[i][2], paths[i][3] * 2, paths[i][3] * 2);
        }
    }
    for (var i = 0 ; i < chests.length ; i++) {
        chests[i].update();
    }
    /*for (var i = 0 ; i < droppedItems.length ; i++) {
        drawIcon(droppedItems[i][0], droppedItems[i][1] - 10, droppedItems[i][2] - 10, 20, 230, false);
        resetMatrix();
        //translate(300, 300);
        //rotate(Player1.ang);
        //translate(-300, -300);
        //translate(300 - Player1.x, 300 - Player1.y);
        translate(300, 300);
        rotate(Player1.ang);
        translate(-300, -300);
        translate(300 - Player1.x, 300 - Player1.y);
    }*/
    /*for (var i = 0 ; i < boats.length ; i++) {
        if (dist(boats[i].x, boats[i].y, Player1.x, Player1.y) < 600) {
            boats[i].display();
        }
        else {
            boats[i].update();
        }
    }*/
    for (var i = 0 ; i < grass.length ; i++) {
        if (dist(Player1.x, Player1.y, grass[i][0], grass[i][1]) < grass[i][2] + 400) {
            for (var j =  grass[i][0] - grass[i][2] / 2; j < grass[i][0] + grass[i][2] / 2; j += 20) {
                for (var k = grass[i][1] - grass[i][2] / 2; k < grass[i][1] + grass[i][2] / 2; k += 20) {
                    
                    if (dist(j, k, grass[i][0], grass[i][1]) > grass[i][2] / 2) {
                        
                        continue;
                    }
                    drawGrass(j, k);
                }
            }
        }
    }
    for (var i = 0 ; i < colorZones.length ; i++) {
        noStroke();
        fill(arrColors[colorZones[i][3]][0], arrColors[colorZones[i][3]][1], arrColors[colorZones[i][3]][2], 125);
        ellipse(colorZones[i][0], colorZones[i][1], colorZones[i][2], colorZones[i][2]);
    }
    for (var i = 0 ; i < beaches.length ; i++) {
        stroke(224, 197, 107);
        noFill();
        strokeWeight(beaches[i][3] - beaches[i][2]);
        ellipse(beaches[i][0], beaches[i][1], (beaches[i][2] + beaches[i][3]), (beaches[i][2] + beaches[i][3]));
    }
};

var heights = [0, 36, 36, 36, 72, 36, 36, 36, 36, 36, 36, 36, 36, 100, 54, 54, 54, 54, 54, 54, 130, 102, 72, 126, 145, 126, 60, 60, 90, 90, 90];

var itemList = ["Empty Space", "Copper Sword", "Silver Sword", "Golden Sword", "Majestic Platinum Sword", "Bronze Bow", "Silver Bow", "Golden Bow", "Sheath of Arrows", "0-25 Health Pack", "25-50 Health Pack", "50-99 Health Pack", "Full Health Pack", "Multi-use Health Pack", "Red Potion", "Green Potion", "Blue Potion", "Yellow Potion", "Purple Potion", "Orange Potion", "Polyjuice", "Mythical Dragon's Sword", "Teleporter", "Sharktooth Fang", "Snakeskin Fang", "Bearjaw Fang", "Empty Bottle", "Bottle of Water", "Beef Jerky", "Nightlock", "Red Berries"];
var mil = [1, 2, 3, 4, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29, 30];

var itemDescriptions = ["", "A basic weapon that deals very low melee damage to a target.", "A weapon that deals low melee damage to a target.", "A weapon that deals medium melee damage to a target.", "A high-quality weapon that deals high damage to a target.", "A ranged weapon that deals medium damage to a target.", "A ranged weapon that deals medium-high damage to a target.", "A high-quality ranged weapon that deals high damage to a target.", "Arrows that can be fired from a bronze, silver, or gold bow.", "A single-use item that heals between 0 and 25 health points.", "A single-use item that heals between 25 and 50 health points.", "A single-use item that heals between 50 and 99 health points.", "A single-use item that heals all of your health points.", "An item that heals between 20-60 health points, and can be used multiple times. Each time you use it, it will require a one minute cooldown before you can use it again.", "A single-use item that allows you to temporarily transform into the color Red.", "A single-use item that allows you to temporarily transform into the color Green.", "A single-use item that allows you to temporarily transform into the color Blue.", "A single-use item that allows you to temporarily transform into the color Yellow.", "A single-use item that allows you to temporarily transform into the color Purple.", "A single-use item that allows you to temporarily transform into the color Orange.", "MYTHICAL ITEM!\nA mythical, multi-use item that allows you to transform into whatever color you want, multiple times! You cannot change into a new color until you have been in a color for 30 seconds. (Unless you have multiple Polyjuices!)", "MYTHICAL ITEM!\nA mythical weapon that deals extremely high melee damage to a target. Can eliminate a player in two hits, or one with a high strength stat.", "MYTHICAL ITEM!\nA mythical, single-use item that allows you to teleport to any location on the map.", "A rare and dangerous item. There are 3 different types of fangs. When holding one or two different types of fangs, you will be slowly dealt damage. However, if you posess one of all 3 fangs, you will be granted powers beyond belief.", "A rare and dangerous item. There are 3 different types of fangs. When holding one or two different types of fangs, you will be slowly dealt damage. However, if you posess one of all 3 fangs, you will be granted powers beyond belief.", "A rare and dangerous item. There are 3 different types of fangs. When holding one or two different types of fangs, you will be slowly dealt damage. However, if you posess one of all 3 fangs, you will be granted powers beyond belief.", "A bottle that can be filled up with water in a lake", "A bottle of water that you can drink from", "A bag of delicious, nutritious beef jerky", "A bag of mysterious black berries. Are they poisonous? Only one way to find out!", "A bag of mysterious red berries. Are they poisonous? Only one way to find out!"];

thestats = [Player1.strength, Player1.speed, Player1.stamina];

var drawBar = function(x, y, v, c, kw) {
    stroke(0, 0, 0);
    strokeWeight(1);
    rectMode(LEFT);
    fill(c);
    rect(x - 100, y - 10, v * 2, 20, 5); 
    noFill();
    rect(x - 100, y - 10, 200, 20, 5);
    rectMode(CENTER);
    fill(0, 0, 0);
    textSize(15);
    text(kw + ": " + v, x, y);
};

var LoadGame = function() {
    saving = false;
    oldach = [];
    for (var i = 0 ; i < achievements.length ; i++) {
        oldach.push(achievements[i].slice());
    }
    oldscene = scene;
    switch (newscene) {
        case "Loading":
            load();
            if (curLoad === Object.keys(imgs).length) {
                newscene = "LoadTransitions";
                frameCount = 0;
            }
            break;
        case "LoadTransitions":
            for (var i = 0 ; i < allimgs.length ; i++) {
                resetMatrix();
                background(0, 0, 0, 0);
                allimgs[i]();
                var chopped1 = [];
                var chopped2 = [];
                chopped1[0] = get(0, 0, 300, 300);
                chopped1[1] = get(300, 0, 300, 300);
                chopped1[2] = get(300, 300, 300, 300);
                chopped1[3] = get(0, 300, 300, 300);
                background(0, 0, 0, 0);
                rotate(-45);
                allimgs[i]();
                chopped2[0] = get(0, 0, 300*Math.sqrt(2), 300*Math.sqrt(2));
                resetMatrix();
                background(0, 0, 0, 0);
                translate(-(600 - 300*Math.sqrt(2)), 0);
                translate(600, 0);
                rotate(-45);
                translate(-600, 0);
                allimgs[i]();
                chopped2[1] = get(0, 0, 300*Math.sqrt(2), 300*Math.sqrt(2));
                resetMatrix();
                background(0, 0, 0, 0);
                translate(-(600 - 300*Math.sqrt(2)), -(600 - 300*Math.sqrt(2)));
                translate(600, 600);
                rotate(-45);
                translate(-600, -600);
                allimgs[i]();
                chopped2[2] = get(0, 0, 300*Math.sqrt(2), 300*Math.sqrt(2));
                resetMatrix();
                background(0, 0, 0, 0);
                translate(0, -(600 - 300*Math.sqrt(2)));
                translate(0, 600);
                rotate(-45);
                translate(0, -600);
                allimgs[i]();
                chopped2[3] = get(0, 0, 300*Math.sqrt(2), 300*Math.sqrt(2));
                imgs1.push(chopped1);
                imgs2.push(chopped2);
            }
            newscene = nextScene;
            break;
        case "Logo":
            
            rectMode(CENTER);
            Logo();
            textAlign(CENTER, CENTER);
            fill(240, 240, 240);
            noStroke();
            strokeWeight(1);
            if (mouseX > 240 && mouseX < 360 && mouseY > 470 && mouseY < 530) {
                cursor(HAND);
                stroke(0, 0, 0);
                if (clicked) {
                    scene = "ChooseAttributes";
                }
            }
            rect(300, 500, 120, 60, 10);
            fill(0, 0, 0);
            textSize(40);
            text("SKIP", 300, 500);
            noStroke();
            if (frameCount > 300) {
                textAlign(CENTER, CENTER);
                scene = "ChooseAttributes";
                strokeWeight(1);
            }
            break;
        case "ChooseAttributes":
            colorBackground();
            textSize(50);
            fill(255, 0, 0);
            textFont(createFont("Avenir"));
            text("WELCOME TO\nCOLOR ARENA!", 300, 100);
            textFont(createFont("Avenir-Light"));
            fill(0, 0, 0);
            textSize(25);
            text("Please set your character's starting\nvalues for strength, speed, and stamina.", 300, 220);
            text("Your character's attributes must add up to 12 in total.", 300, 280);
            fill(75, 0, 0);
            textAlign(LEFT, CENTER);
            textSize(22);
            text("Strength: " + strength, 5, 340);
            fill(0, 75, 0);
            text("Speed: " + attrspeed, 5, 400);
            fill(0, 0, 75);
            text("Stamina: " + stamina, 5, 460);
            textFont(createFont("monospace"));
            textAlign(CENTER, CENTER);
            rectMode(LEFT);
            stroke(0, 0, 0);
            strokeWeight(1);
            noFill();
            rect(180, 327.5, 350, 25);
            rect(180, 387.5, 350, 25);
            rect(180, 447.5, 350, 25);
            noStroke();
            fill(255, 0, 0);
            rect(180.5, 329, 350 * (strength / 12) - 1, 24);
            fill(0, 255, 0);
            rect(180.5, 389, 350 * (attrspeed / 12) - 1, 24);
            fill(0, 0, 255);
            rect(180.5, 449, 350 * (stamina / 12) - 1, 24);
            rectMode(CENTER);
            for (var i = 340 ; i <= 460 ; i += 60) {
                fill(0, 0, 125);
                rect(150, i, 30, 30, 3);
                rect(560, i, 30, 30, 3);
                fill(255, 255, 255);
                text("-", 150, i);
                text("+", 560, i);
                if (mouseX > 135 && mouseX < 165 && mouseY > i - 15 && mouseY < i + 15) {
                    cursor(HAND);
                    if (clicked) {
                        if (i === 340 && strength > 0) {
                            strength --;
                        }
                        else if (i === 400 && attrspeed > 0) {
                            attrspeed --;
                        }
                        else if (i === 460 && stamina > 0) {
                            stamina --;
                        }
                    }
                }
                if (mouseX > 545 && mouseX < 575 && mouseY > i - 15 && mouseY < i + 15) {
                    cursor(HAND);
                    if (clicked) {
                        if (i === 340 && strength < 12) {
                            strength ++;
                        }
                        else if (i === 400 && attrspeed < 12) {
                            attrspeed ++;
                        }
                        else if (i === 460 && stamina < 12) {
                            stamina ++;
                        }
                    }
                }
            }
            fill(255, 0, 0);
            if (strength + attrspeed + stamina === 12) {
                fill(0, 255, 0);
            }
            textFont(createFont("Avenir-Light"));
            text("Total Attribute Sum: " + (strength+attrspeed+stamina), 300, 500);
            fill(0, 0, 0, 50);
            if (mouseX > 225 && mouseX < 375 && mouseY > 525 && mouseY < 585) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked && (strength+attrspeed+stamina)===12) {
                    scene = "Menu";
                    Player1.strength = strength;
                    Player1.speed = attrspeed;
                    Player1.stamina = stamina;
                    Player1.trainingScore = (strength + attrspeed + stamina) / 3;
                    Player1.speedF = 1.5 * Player1.speed;
                }
            }
            rect(300, 555, 150, 60, 20);
            fill(0, 255, 0);
            textFont(createFont("monospace"));
            text("Continue", 300, 555);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case "Menu":
            ticks[8] = false;
            if (chests.length > 4) {
                chests = [];
            }
            if (elimd) {
                loadTransitionPos = [-600, 2100];
                paused = false;
                sf = 0.03;
                countdown = 3;
                var oldstmenu = [Player1.strength, Player1.speed, Player1.stamina, Player1.incr[0], Player1.incr[1], Player1.incr[2]];
                Player1 = new Player();
                Player1.strength = oldstmenu[0];
                Player1.speed = oldstmenu[1];
                Player1.stamina = oldstmenu[2];
                Player1.strength += characterStats[selch][0];
                Player1.speed += characterStats[selch][1];
                Player1.stamina += characterStats[selch][2];
                Player1.trainingScore = (Player1.strength + Player1.speed + Player1.stamina) / 3;
                Player1.incr[0] = oldstmenu[3];
                Player1.incr[1] = oldstmenu[4];
                Player1.incr[2] = oldstmenu[5];
                ticks[5] = false;
                elimd = false;
                displayed = false;
            }
            colorBackground();
            //image(imgs.noisyDirt, 0, 0);
            fill(255, 0, 0);
            textSize(80);
            textFont(createFont("Avenir"));
            text("COLOR", 300, 100);
            fill(0, 215, 0);
            text("ARENA", 300, 180);
            fill(0, 0, 255);
            textSize(20);
            text("Arena survival game with AIs", 300, 260);
            textFont(createFont("AvenirNext-UltraLight"));
            fill(0, 0, 0, 55);
            if (mouseX > 75 && mouseX < 225 && mouseY > 310 && mouseY < 390 && !showInstructions) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked) { 
                    if (instructionsRead) {
                        scene = "Settings";
                    }
                    else {
                        showInstructions = true;
                    }
                }
            }
            rect(150, 350, 150, 80, 20);
            fill(0, 0, 0, 55);
            if (mouseX > 375 && mouseX < 525 && mouseY > 310 && mouseY < 390 && !showInstructions) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked) {
                    scene = "TutorialF";
                    
                }
            }
            rect(450, 350, 150, 80, 20);
            fill(0, 0, 0, 55);
            if (mouseX > 75 && mouseX < 225 && mouseY > 440 && mouseY < 520 && !showInstructions) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked) {
                    scene = "Achievements";
                }
            }
            rect(150, 480, 150, 80, 20);
            fill(0, 0, 0, 55);
            if (mouseX > 375 && mouseX < 525 && mouseY > 440 && mouseY < 520 && !showInstructions) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked) {
                    scene = "Shop";
                }
            }
            rect(450, 480, 150, 80, 20);
            fill(255, 0, 0);
            textFont(createFont("monospace"));
            textSize(25);
            text("Play\nMatch", 150, 350);
            fill(0, 255, 0);
            textSize(24);
            text("Tutorial", 450, 350);
            fill(0, 0, 255);
            textSize(18);
            text("Achievements", 150, 480);
            textSize(30);
            fill(255, 255, 0);
            text("Shop", 450, 480);
            
            fill(255, 0, 0);
            textSize(20);
            //text("Made by Plourde27 Programming in Summer 2018", 300, 568);
            fill(0, 0, 0, 55);
            if (mouseX > 140 && mouseX < 220 && mouseY > 540 && mouseY < 580) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked) {
                    scene = "About";
                }
            }
            rect(180, 560, 80, 40, 15);
            fill(0, 0, 0, 55);
            if (mouseX > 380 && mouseX < 460 && mouseY > 540 && mouseY < 580) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked) {
                    saving = true;
                }
            }
            rect(420, 560, 80, 40, 15);
            textSize(20);
            fill(255, 0, 255);
            text("About", 180, 560);
            fill(0, 255, 255);
            text("Save", 420, 560);
            textFont(createFont("AvenirNext-UltraLight"));
            for (var i = 0 ; i < 12 ; i++) {
                drawIcon(mil[i % mil.length], i * 50, 0, 50, 200, [255, 255, 255], true);
            }
            for (var i = 12 ; i < 23 ; i++) {
                drawIcon(mil[i % mil.length], 550, (i - 11) * 50, 50, 200, [255, 255, 255],true);
            }
            for (var i = 23 ; i < 34 ; i++) {
                drawIcon(mil[i % mil.length], 0, -(i - 34) * 50, 50, 200, [255, 255, 255], true);
            }
            resetMatrix();
            if (showInstructions) {
                noStroke();
                fill(0, 0, 0, 200);
                rect(300, 300, 600, 600);
                fill(255, 255, 255);
                rect(300, 300, 360, 100, 20);
                stroke(200, 200, 200);
                strokeWeight(1);
                line(120, 285, 480, 285);
                fill(200, 200, 200);
                textSize(25);
                textFont(createFont("Avenir"));
                text("Please Play the Tutorial", 285, 267);
                
                textSize(18);
                textAlign(LEFT, TOP);
                fill(0, 0, 0);
                text("This game has many complex features. Please play the tutorial before playing.", 130, 290, 350, 600);
                textFont(createFont("AvenirNext-UltraLight"));
                textAlign(CENTER, CENTER);
                fill(50, 50, 50, 200);
                if (mouseX > 447 && mouseX < 467 && mouseY > 257 && mouseY < 277) {
                    cursor(HAND);
                    fill(40, 40, 40, 220);
                    if (clicked) {
                        showInstructions = false;
                        instructionsRead = true;
                    }
                }
                rect(457, 267, 20, 20, 5);
                stroke(255, 255, 255);
                
                line(453, 263, 461, 271);
                line(461, 263, 453, 271);
            }
            break;
        case "About":
            colorBackground();
            stroke(0, 0, 0);
            line(0, 100, 600, 100);
            fill(125, 0, 125);
            textSize(70);
            text("ABOUT", 300, 50);
            fill(0, 0, 0);
            textSize(20);
            textAlign(LEFT, TOP);
            text("Color Arena is an arena game.\nThis program was finished on November 5, 2018 by Plourde27.\nIn my opinion, this is my favorite game that I have made, ahead of my previous favorite, Ultimate Ski Race.\nThis is, to the extent of my knowledge, the first full, working arena game on Khan Academy. If you have knowledge of a different one please post it in the Tips & Thanks.\nThe other players are computer-controlled, and designed to act as realistic as possible.\nI hope you enjoy this, I have worked hard on it for months.", 30, 140, 540, 600);
            textAlign(CENTER, CENTER);
            fill(0, 0, 0, 55);
            noStroke();
            if (mouseX > 235 && mouseX < 365 && mouseY > 505 && mouseY < 575) {
                fill(0, 0, 0, 75);
                cursor(HAND);
                if (clicked) {
                    scene = "Menu";
                }
            }
            rect(300, 540, 130, 70, 20);
            fill(255, 0, 0);
            textFont(createFont("monospace"));
            textSize(30);
            text("Back", 300, 540);
            break;
        case "TutorialF":
            colorBackground();
            stroke(0, 0, 0);
            line(0, 100, 600, 100);
            fill(0, 0, 255);
            textSize(70);
            text("TUTORIAL", 300, 50);
            fill(0, 0, 0);
            textSize(23);
            textAlign(LEFT, TOP);
            text("Welcome to Color Arena!\nThis is an arena game, where you compete in an arena of about 24 players. The goal is to be the last player standing, by eliminating other players and by collecting useful chest items to survive.\nThis is the largest and personal favorite of my games, and I hope you enjoy.\n\nClick to play a hands-on tutorial of controls and mechanics.", 30, 140, 540, 600);
            textAlign(CENTER, CENTER);
            if (clicked) {
                borderDist = 100000;
                scene = "Tutorial";
                mapSeed = 6;
                LoadMap();
                instructionsRead = true;
                players = [Player1];
            }
            break;
        case "Tutorial":
            countdown = 0;
            
            invtf = constrain(invtf, 50, 255);
            players = [Player1];
            splicinds = [];
            background(255, 255, 255);
            matchtime++;
            background(255, 255, 255);
            colortf *= 0.98;
            resetMatrix();
            pushMatrix();
            //scale(0.1);
            translate(300, 300);
            rotate(Player1.ang);
            translate(-300, -300);
            invtf *= 0.98;
            if (mouseY > 390) {
                invtf *= 1.2;
            }
            background(255, 255, 255);
            //pushMatrix();
            resetMatrix();
            translate(300, 0);
            //scale(sf);
            translate(-300, 0);
            pushMatrix();
            translate(300, 300);
            rotate(Player1.ang);
            translate(-300, -300);
            translate(300 - Player1.x, 300 - Player1.y);
            //if (!paused) {
                DrawMap();
            //}
            //else {
            //    DrawMap(false, true);
            //}
             resetMatrix();
             translate(300, 0);
            //scale(sf);
            translate(-300, 0);
             //scale(0.1);
             translate(300, 300);
            rotate(Player1.ang);
            translate(-300, -300);
             translate(300 - Player1.x, 300 - Player1.y);
             fill(0, 0, 0);
            textSize(18);
            textFont(createFont("Avenir"));
            text("This tutorial will give you\na hands-on experience and a feel\nfor the controls used in the\ngame. Use the up arrow key to\nmove forward, the down arrow\nkey to move backwards, and the right and\nleft arrow keys to turn.\nMove forward to continue.\nWASD controls are also supported.", 315, 130);
            text("This is a chest.\nChests contain useful items.\nTo open a chest, press \"ENTER\"\nwhen on a chest.\nYou can select items from the chest and\nput them into your inventory.", 300, -250);
            text("In real matches, the goal\nis to be the last player standing.\nThese chest items will help you\nto achieve that.\nTo hit a player, press SPACE.", 300, -600);
            textAlign(LEFT, TOP);
            text("In addition, each player also has a color, and each player starts out with White color. Players can change their color by using potions. Certain zones on the map are only accessible by players of a certain color. Everyone can enter a white zone, nobody can enter a black zone, and all other zones a player can access that zone if they are the same color as the color of the zone.\n\nThe border is constantly shrinking, and if you get caught outside the border you will take heavy damage.", 190, -1270, 220, 1000);
            textAlign(CENTER, CENTER);
            text("That is it for the tutorial!\nClick to exit to the menu.\n\nIn addition, lakes, plains,\nand other features appear in\ndifferent maps, which will be\nexplained in matches.", 300, -1450);
            //if (!displayed) {
            for (var i = 0 ; i < players.length ; i++) {
                //if (players[i].cpuControlled) {
                players[i].display();
                    //players[i].draww();
                //}
            }
            resetMatrix();
            for (var i = 0 ; i < 3; i++) {
                for (var j = 0 ; j < 9; j++) {
                    noStroke();
                    resetMatrix();
                    
                    invInd = i * 9 + j;
                    invW = 45;
                    invH = 45;
                    invX = 60 + j * 60 - invW / 2;
                    invY = 440 + i * 60 - invH / 2;
                    invIcon = itemList.indexOf(Player1.inventory[invInd]);
                    if (mouseX > invX && mouseX < invX + invW && mouseY > invY && mouseY < invY + invH && invIcon > 0 && !displayed) {
                        fill(210, 210, 210);
                        cursor(HAND);
                        if (clicked && Player1.weaponInd !== invInd) {
                            Player1.weapon = Player1.inventory[invInd];
                            Player1.weaponInd = invInd;
                        }
                        else if (clicked) {
                            Player1.weapon = "";
                            Player1.weaponInd = "No Weapon";
                        }
                        
                        fill(210, 210, 210, invtf);
                    }
                    noStroke();
                    if (Player1.weaponInd === invInd) {
                        strokeWeight(3);
                        stroke(0, 0, 0, invtf);
                    }
                    fill(200, 200, 200, invtf);
                    
                    rect(invX + invW / 2, invY + invH / 2, 45, 45, 5);
                    if (invIcon === 8) {
                        fill(0, 0, 0);
                        noStroke();
                        strokeWeight(1.5);
                        rect(invX + invW, invY, 20, 20, 2);
                        fill(255, 255, 255);
                        textFont(createFont("monospace"));
                        textSize(10);
                        text("x" + Player1.arrowcount[invInd], invX + invW, invY);
                        textFont(createFont("AvenirNext-UltraLight"));
                    }
                    drawIcon(invIcon, invX, invY, 45, invtf, [200, 200, 200, invtf]);
                    
                    resetMatrix();
                }
            }
            for (var i = 0 ; i < 3; i++) {
                for (var j = 0 ; j < 9; j++) {
                    resetMatrix();
                    invInd = i * 9 + j;
                    invW = 45;
                    invH = 45;
                    invX = 60 + j * 60 - invW / 2;
                    invY = 440 + i * 60 - invH / 2;
                    invIcon = itemList.indexOf(Player1.inventory[invInd]);
                    if (mouseX > invX && mouseX < invX + invW && mouseY > invY && mouseY < invY + invH && invIcon > 0 && !displayed) {
                        fill(255, 255, 255, 200);
                        stroke(125, 125, 125);
                        strokeWeight(1);
                        rectMode(LEFT);
                        if (j < 6) {
                            rect(mouseX, mouseY - heights[invIcon] - 20, 200, heights[invIcon] + 20, 3);
                        }
                        else {
                            rect(mouseX - 200, mouseY - heights[invIcon] - 20, 200, heights[invIcon] + 20, 3);
                        }
                        rectMode(CENTER);
                        fill(0, 0, 0);
                        textFont(createFont("Avenir"));
                        textAlign(LEFT, TOP);
                        textSize(12);
                        if (j < 6) {
                            text(itemList[invIcon] + "\n" + itemDescriptions[invIcon], mouseX + 5, mouseY - heights[invIcon] - 20, 190, heights[invIcon] + 20);
                        }
                        else {
                            text(itemList[invIcon] + "\n" + itemDescriptions[invIcon], mouseX - 195, mouseY - heights[invIcon] - 20, 190, heights[invIcon] + 20);
                        }
                        textFont(createFont("AvenirNext-UltraLight"));
                        textAlign(CENTER, CENTER);
                    }
                }
            }
            if (displayed) {
                fill(125, 125, 125, 200);
                noStroke();
                rect(300, 300, 600, 600);
                fill(125, 125, 125);
                fill(200, 200, 200);
                noStroke();
                for (var i = 0 ; i < chestItems.length / 9; i++) {
                    for (var j = 0 ; j < Math.min(chestItems.length - i * 9, 9); j++) {
                        noStroke();
                        var chestInd = i * 9 + j;
                        var chestW = 45;
                        var chestH = 45;
                        var chestX = 60 + j * 60 - chestW / 2;
                        var chestY = 120 + i * 60 - chestH / 2;
                        var chestIcon = itemList.indexOf(chestItems[chestInd]);
                        fill(200, 200, 200);
                        if (mouseX > chestX && mouseX < chestX + chestW && mouseY > chestY && mouseY < chestY + chestH && chestIcon > 0) {
                            fill(210, 210, 210);
                            cursor(HAND);
                            if (clicked && !Player1.inventoryFull && chestItems[chestInd] !== "Sheath of Arrows") {
                                Player1.inventory[Player1.lastEmptySpace] = chestItems[chestInd];
                                chests[dispChestInd].items[chestInd] = "Empty Space";
                            }
                            else if (clicked && chestItems[chestInd] === "Sheath of Arrows") {
                                var arrowFound = false;
                                Player1.arrow = true;
                                for (var k = 0 ; k < Player1.inventory.length ; k++) {
                                    if (Player1.inventory[k] === "Sheath of Arrows" && !arrowFound) {
                                        Player1.arrowcount[k] += 10;
                                        arrowFound = true;
                                        chests[dispChestInd].items[chestInd] = "Empty Space";
                                    }
                                }
                                if (!arrowFound) {
                                    if (Player1.inventoryFull) {
                                        Player1.arrow = false;
                                    }
                                    else {
                                        Player1.inventory[Player1.lastEmptySpace] = "Sheath of Arrows";
                                        Player1.arrow = true;
                                        Player1.arrowcount[Player1.lastEmptySpace] = 10;
                                        chests[dispChestInd].items[chestInd] = "Empty Space";
                                    }
                                }
                            }
                        }
                        rect(60 + j * 60, 120 + i * 60, 45, 45, 5);
                        drawIcon(chestIcon, chestX, chestY, 45, 255, [200, 200, 200]);
                        resetMatrix();
                    }
                }
                fill(0, 0, 0);
                textSize(18);
                text("Press \"X\" or the button on the left to exit", 300, 50);
                fill(100, 100, 100);
                if (dist(mouseX, mouseY, 50, 50) < 25) {
                    fill(110, 110, 110);
                    cursor(HAND);
                    if (clicked) {
                        displayed = false;
                        chests[dispChestInd].displayed = false;
                    }
                }
                if (keys[88] && pressed) {
                    displayed = false;
                    chests[dispChestInd].displayed = false;
                }
                
                noStroke();
                ellipse(50, 50, 50, 50);
                stroke(0, 0, 0);
                strokeWeight(5);
                line(40, 40, 60, 60);
                line(60, 40, 40, 60);
                for (var i = 0 ; i < chestItems.length / 9; i++) {
                    for (var j = 0 ; j < Math.min(chestItems.length - i * 9, 9); j++) {
                        var chestInd = i * 9 + j;
                        var chestW = 45;
                        var chestH = 45;
                        var chestX = 60 + j * 60 - chestW / 2;
                        var chestY = 120 + i * 60 - chestH / 2;
                        var chestIcon = itemList.indexOf(chestItems[chestInd]);
                        if (mouseX > chestX && mouseX < chestX + chestW && mouseY > chestY && mouseY < chestY + chestH && chestIcon > 0) {
                            fill(255, 255, 255, 200);
                            stroke(125, 125, 125);
                            strokeWeight(1);
                            rectMode(LEFT);
                            if (j < 6) {
                                rect(mouseX, mouseY - heights[chestIcon] - 20, 200, heights[chestIcon] + 20, 3);
                            }
                            else {
                                rect(mouseX - 200, mouseY - heights[chestIcon] - 20, 200, heights[chestIcon] + 20, 3);
                            }
                            rectMode(CENTER);
                            fill(0, 0, 0);
                            textFont(createFont("Avenir"));
                            textAlign(LEFT, TOP);
                            textSize(12);
                            if (j < 6) {
                                text(itemList[chestIcon] + "\n" + itemDescriptions[chestIcon], mouseX + 5, mouseY - heights[chestIcon] - 20, 190, heights[chestIcon] + 20);
                            }
                            else {
                                text(itemList[chestIcon] + "\n" + itemDescriptions[chestIcon], mouseX - 195, mouseY - heights[chestIcon] - 20, 190, heights[chestIcon] + 20);
                            }
                            textFont(createFont("AvenirNext-UltraLight"));
                            textAlign(CENTER, CENTER);
                        }
                    }
                }
            }
            if (clicked && Player1.y < -1100) {
                newscene = "Menu";
                paused = false;
                countdown = 3;
                elimd = true;
                loadTransitionPos = [-600, 2100];
            }
            break;
        case "How":
            colorBackground();
            fill(255, 0, 0);
            textSize(60);
            textFont(createFont("Avenir"));
            text("INSTRUCTIONS", 370, 50);
            fill(0, 0, 0, 55);
            if (mouseX > 11 && mouseX < 141 && mouseY > 15 && mouseY < 85) {
                fill(0, 0, 0, 75);
                cursor(HAND);
                if (clicked) {
                    scene = "Menu";
                }
            }
            rect(76, 50, 130, 70, 20);
            fill(0, 0, 255);
            textFont(createFont("monospace"));
            textSize(30);
            text("Back", 76, 50);
            stroke(0, 0, 0);
            strokeWeight(1);
            line(0, 100, 600, 100);
            fill(0, 0, 0);
            textSize(40);
            text("Page " + page + " / 15", 300, 150);
            fill(125, 125, 125);
            noStroke();
            if (page > 1) {
                if (mouseX > 100 && mouseX < 120 && mouseY > 130 && mouseY < 170) {
                    cursor(HAND);
                    if (clicked) {
                        page--;
                    }
                }
                triangle(120, 130, 100, 150, 120, 170);
            }
            if (page < 15) {
                if (mouseX > 480 && mouseX < 500 && mouseY > 130 && mouseY < 170) {
                    cursor(HAND);
                    if (clicked) {
                        page++;
                    }
                }
                triangle(480, 130, 500, 150, 480, 170);
            }
            textFont(createFont("Avenir-Light"));
            textSize(22);
            fill(0, 0, 0);
            textAlign(LEFT, TOP);
            text(instr[page - 1], 50, 200, 500, 600);
            textAlign(CENTER, CENTER);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case "Achievements":
            colorBackground();
            fill(0, 255, 0);
            textSize(50);
            textFont(createFont("Avenir"));
            text("ACHIEVEMENTS", 370, 50);
            fill(0, 0, 0, 55);
            if (mouseX > 11 && mouseX < 141 && mouseY > 15 && mouseY < 85) {
                fill(0, 0, 0, 75);
                cursor(HAND);
                if (clicked) {
                    scene = "Menu";
                }
            }
            rect(76, 50, 120, 70, 20);
            fill(0, 0, 255);
            textFont(createFont("monospace"));
            textSize(27);
            text("Back", 76, 50);
            stroke(0, 0, 0);
            strokeWeight(1);
            line(0, 100, 600, 100);
            textSize(18);
            for (var i = 0 ; i < 5 ; i++) {
                textFont(createFont("Avenir"));
                textSize(18);
                fill(achievementColors[i]);
                textAlign(LEFT, TOP);
                text(achievementNames[i], 20, 100 + i * 100);
                textAlign(CENTER, CENTER);
                noStroke();
                fill(200, 200, 200, 50);
                var achTick = 50;
                for (var j = 0 ; j < 6 ; j++) {
                    if ((j > 0 && i === 4) || (i === 3 && !achievements[i * 6 + j][2]) || (i === 4 && j === 0 && !achievements[i * 6 + j][2])) {
                        continue;
                    }
                    
                    var achNum = i * 6 + j;
                    fill(200, 200, 200, 200);
                    noStroke();
                    rect(achTick, 160 + i * 100, 60, 60, 10);
                    drawAchievement(achTick, 160 + i * 100, i);
                    
                    if (!achievements[achNum][2]) {
                        fill(255, 255, 255, 100);
                        noStroke();
                        rect(achTick, 160 + i * 100, 60, 60, 10);
                    }
                    achTick += 100;
                }
                if (achTick === 50) {
                    fill(0, 0, 0);
                    textSize(18);
                    textFont(createFont("AvenirNext-UltraLight"));
                    textAlign(LEFT, CENTER);
                    text(nonAchievementNames[i] + " Achievements are hidden until you have completed them." , 30, 160 + i * 100);
                    textAlign(CENTER, CENTER);
                }
            }
            for (var i = 0 ; i < 5 ; i++) {
                var achTick = 50;
                for (var j = 0 ; j < 6 ; j++) {
                    if ((j > 0 && i === 4) || (i === 3 && !achievements[i * 6 + j][2]) || (i === 4 && j === 0 && !achievements[i * 6 + j][2])) {
                        continue;
                    }
                    var achNum = i * 6 + j;
                    if (mouseX > achTick - 30 && mouseX < achTick + 30 && mouseY > 130 + i * 100 && mouseY < 190 + i * 100) {
                        cursor(HAND);
                        fill(255, 255, 255);
                        stroke(0, 0, 0);
                        strokeWeight(1);
                        rectMode(LEFT);
                        var achLen = achievements[achNum][1].split("").length;
                        if (achNum === 20 || achNum === 1 || achNum === 14 || achNum === 22) {
                            achLen += 20;
                        }
                        if (achNum === 24) {
                            achLen += 40;
                        }
                        var achx;
                        var achy;
                        if (achTick < 550) {
                            achx = mouseX;
                        }
                        else {
                            achx = mouseX - 120;
                        }
                        if (i < 4) {
                            achy = mouseY;
                        }
                        else {
                            if (achNum === 20 || achNum === 1 || achNum === 14 || achNum === 22) {
                                achy = mouseY - 165;
                            }
                            else if (achNum === 24) {
                                achy = mouseY - 180;
                            }
                            else {
                                achy = mouseY - 150;
                            }
                        }
                        //if (j < 5) {
                        if (achNum !== 24) {
                            rect(achx, achy, 120, 30 + (Math.floor(achLen / 20) + 1) * 15 + 6);
                        }
                        else {
                            rect(achx, achy, 120, 30 + (Math.floor(achLen / 20) + 1) * 15 + 12);
                        }
                        //}
                        //else {
                        //rect(mouseX - 120, mouseY, 120, 30 + (Math.floor(achLen / 20) + 1) * 15 + 6);
                        //}
                        
                        rectMode(CENTER);
                        if (achievements[achNum][2]) {
                            fill(0, 55, 0);
                        }
                        else {
                            fill(55, 0, 0);
                        }
                        textSize(15);
                        textFont(createFont("Avenir"));
                        textAlign(LEFT, TOP);
                        text(achievements[achNum][0], achx + 3, achy + 3);
                        stroke(0, 0, 0);
                        line(achx, achy + 26, achx + 120, achy + 26);
                        textSize(12);
                        fill(0, 0, 0);
                        text(achievements[achNum][1], achx + 3, achy + 29, 104, 600);
                        textAlign(CENTER, CENTER);
                    }
                    achTick += 100;
                }
            }
            if (achievements[0][2] && achievements[1][2] && achievements[2][2] && achievements[3][2] && achievements[4][2] && achievements[5][2]) {
                achievements[11][2] = true;
            }
            if (achievements[6][2] && achievements[7][2] && achievements[8][2] && achievements[9][2] && achievements[10][2] && achievements[11][2]) {
                achievements[17][2] = true;
            }
            if (achievements[12][2] && achievements[13][2] && achievements[14][2] && achievements[15][2] && achievements[16][2] && achievements[17][2]) {
                achievements[23][2] = true;
            }
            if (achievements[18][2] && achievements[19][2] && achievements[20][2] && achievements[21][2] && achievements[22][2] && achievements[23][2]) {
                achievements[24][2] = true;
            }
            fill(0, 0, 0, 55);
            break;
        case "Shop":
            colorBackground();
            fill(0, 0, 255);
            textSize(80);
            textFont(createFont("Avenir"));
            text("SHOP", 300, 50);
            stroke(0, 0, 0);
            strokeWeight(1);
            line(0, 100, 600, 100);
            textFont(createFont("Avenir-Light"));
            fill(0, 0, 0);
            textSize(16);
            textAlign(LEFT, TOP);
            text("Buy new characters in the shop for in-game currency. Character stats are added onto your base stats which fluctuate during matches. Click on a character to view its full description.", 10, 100, 580, 600);
            textAlign(CENTER, CENTER);
            for (var i = 0 ; i < pos.length ; i++) {
                fill(255, 255, 255);
                if (owned[i]) {
                    fill(220, 255, 220);
                }
                if (mouseX > pos[i][0] - 60 && mouseX < pos[i][0] + 60 && mouseY > pos[i][1] - 60 && mouseY < pos[i][1] + 60) {
                    cursor(HAND);
                    if (clicked) {
                        charselected = i;
                    }
                }
                stroke(200, 200, 200);
                strokeWeight(1);
                rect(pos[i][0], pos[i][1], 120, 120, 20);
                fill(0, 0, 0);
                textSize(30);
                text(characterNames[i], pos[i][0], pos[i][1] - 42);
                line(pos[i][0] - 60, pos[i][1] - 24, pos[i][0] + 60, pos[i][1] - 24);
                
                textSize(16);
                fill(75, 0, 0);
                text("Strength: +" + characterStats[i][0], pos[i][0], pos[i][1] - 8);
                fill(0, 75, 0);
                text("Speed: +" + characterStats[i][1], pos[i][0], pos[i][1] + 18);
                fill(0, 0, 75);
                text("Stamina: +" + characterStats[i][2], pos[i][0], pos[i][1] + 42);
            }
            fill(230, 230, 230, 200);
            rect(300, 520, 600, 160);
            textAlign(LEFT, CENTER);
            fill(0, 0, 0);
            textSize(30);
            text(characterNames[charselected], 20, 460);
            textSize(25);
            if (money >= costs[charselected]) {
                fill(0, 125, 0);
            }
            else {
                fill(255, 0, 0);
            }
            text("Price: " + costs[charselected], 150, 463);
            fill(0, 0, 0);
            if (!owned[charselected]) {
                textAlign(CENTER, CENTER);
            }
            if (owned[charselected]) {
                if (selch === charselected) {
                    textSize(18);
                    text("You are currently using this character.", 265, 463);
                }
                else {
                    fill(0, 0, 0, 55);
                    if (mouseX > 290 && mouseX < 390 && mouseY > 443 && mouseY < 483) {
                        cursor(HAND);
                        fill(0, 0, 0, 75);
                        if (clicked) {
                            Player1.strength -= characterStats[selch][0];
                            Player1.speed -= characterStats[selch][1];
                            Player1.stamina -= characterStats[selch][2];
                            selch = charselected;
                            Player1.strength += characterStats[selch][0];
                            Player1.speed += characterStats[selch][1];
                            Player1.stamina += characterStats[selch][2];
                        }
                    }
                    rect(340, 463, 100, 40, 10);
                    fill(0, 200, 0);
                    textSize(18);
                    textFont(createFont("monospace"));
                    textAlign(CENTER, CENTER);
                    text("Use", 340, 463);
                }
            }
            else {
                fill(0, 0, 0, 55);
                if (mouseX > 290 && mouseX < 390 && mouseY > 443 && mouseY < 483) {
                    cursor(HAND);
                    fill(0, 0, 0, 75);
                    if (clicked && money >= costs[charselected]) {
                        rookieBuyer = true;
                        owned[charselected] = true;
                        money -= costs[charselected];
                    }
                }
                rect(340, 463, 100, 40, 10);
                fill(255, 0, 0);
                textSize(18);
                textFont(createFont("monospace"));
                text("Purchase", 340, 463);
            }
            drawChar(charselected);
            textAlign(LEFT, TOP);
            textFont(createFont("Avenir"));
            fill(0, 0, 0);
            textSize(18);
            text(characterDescriptions[charselected], 250, 490, 320, 300);
            textAlign(CENTER, CENTER);
            
            fill(0, 0, 0, 55);
            if (mouseX > 40 && mouseX < 160 && mouseY > 20 && mouseY < 80) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked) {
                    scene = "Menu";
                }
            }
            noStroke();
            rect(100, 50, 120, 60, 20);
            textFont(createFont("monospace"));
            fill(255, 0, 0);
            textSize(23);
            text("Back", 100, 50);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case "Settings":
            //oldpn = 2 + playerOptions.length * 1000;
            //oldcn = 1 + colorOptions.length * 1000;
            colorBackground();
            fill(255, 0, 0);
            textSize(80);
            textFont(createFont("Avenir"));
            text("SETTINGS", 300, 50);
            fill(0, 0, 255);
            textSize(20);
            textFont(createFont("AvenirNext-UltraLight"));
            text("Select how many players will be competing in the match, \nand the amount of colors available.", 300, 130);
            fill(0, 0, 0);
            text("Players: ", 150, 200);
            text("Amount of colors: ", 150, 300);
            //if (scene === "Settings") {
                text(playerOptions[oldpn % playerOptions.length], 400, 200);
                text(colorOptions[oldcn % colorOptions.length], 400, 300);
            //}
            //else {
            //    text(oldpn, 400, 200);
            //    text(oldcn, 400, 300);
            //}
            fill(125, 125, 125);
            triangle(355, 190, 345, 200, 355, 210);
            triangle(445, 190, 455, 200, 445, 210);
            triangle(355, 290, 345, 300, 355, 310);
            triangle(445, 290, 455, 300, 445, 310);
            if (mouseX > 345 && mouseX < 355 && mouseY > 190 && mouseY < 210) {
                cursor(HAND);
                if (clicked) {
                    oldpn --;
                }
            }
            if (mouseX > 445 && mouseX < 455 && mouseY > 190 && mouseY < 210) {
                cursor(HAND);
                if (clicked) {
                    oldpn ++;
                }
            }
            if (mouseX > 345 && mouseX < 355 && mouseY > 290 && mouseY < 310) {
                cursor(HAND);
                if (clicked) {
                    oldcn --;
                }
            }
            if (mouseX > 445 && mouseX < 455 && mouseY > 290 && mouseY < 310) {
                cursor(HAND);
                if (clicked) {
                    oldcn ++;
                }
            }
            fill(0, 0, 0);
            text("The map seed is always randomized before the match.", 300, 400);
            fill(0, 0, 0, 55);
            if (mouseX > 225 && mouseX < 375 && mouseY > 470 && mouseY < 550) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked && scene === "Settings") {
                    playerNum = playerOptions[oldpn % playerOptions.length];
                    if (playerNum === "Random") {
                        while (playerNum === "Random") {
                            playerNum = playerOptions[round(random(-0.4, playerOptions.length - 0.6))];
                        }
                    }
                    colorNum = colorOptions[oldcn % colorOptions.length];
                    if (colorNum === "Random") {
                        while (colorNum === "Random") {
                            colorNum = colorOptions[round(random(-0.4, colorOptions.length - 0.6))];
                        }
                    }
                    Player1.trainingScore = (Player1.strength + Player1.speed + Player1.stamina) / 3;
                    players = [Player1];
                    var aiInds = shuffle(numsArr);
                    for (var i = 0 ; i < playerNum - 1 ; i++) {
                        players.push(new AIPlayer(i + 2, playerNum, ai[aiInds[i]].name, ai[aiInds[i]].strategy, ai[aiInds[i]].stats, ai[aiInds[i]].timelimit));
                    }
                    scene = "BeforePlay";
                    startingColors = colorNum;
                    //otplayers = players.slice();
                    
                    shufplayers = players.slice().sort(function(a, b) { return b.trainingScore - a.trainingScore; });
                }
            }
            rect(300, 510, 150, 80, 20);
            fill(0, 255, 0);
            textFont(createFont("monospace"));
            text("Start", 300, 510);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case "BeforePlay":
            colorBackground();
            stroke(0, 0, 0);
            line(0, 80, 600, 80);
            fill(255, 0, 0);
            textSize(50);
            textFont(createFont("Avenir"));
            text("PLAYERS IN THIS MATCH", 300, 40);
            textFont(createFont("AvenirNext-UltraLight"));
            for (var i = 0 ; i < playerNum; i++) {
                
                fill(200, 200, 200, 55);
                noStroke();
                var py = 80 + ((i + 1) * (500 / playerNum)) - (500 / playerNum) * (1/4);
                rect(300, 80 + ((i + 1) * (500 / playerNum)) - (500 / playerNum) * (1/4), 580, (500 / playerNum) * 0.9);
                textSize(Math.min((500 / 24) * 0.8, (500 / playerNum) * 0.8));
                fill(0, 0, 0);
                textFont(createFont("monospace"));
                textAlign(LEFT, CENTER);
                text(shufplayers[i].name, 30, py);
                stroke(0, 0, 0);
                line(240, py - (500 / playerNum) * 0.9 / 2, 240, py + (500 / playerNum) * 0.9 / 2);
                line(395, py - (500 / playerNum) * 0.9 / 2, 395, py + (500 / playerNum) * 0.9 / 2);
                fill(0, 0, 0);
                text("Stats:", 250, py);
                fill(125, 0, 0);
                text(shufplayers[i].strength, 320, py);
                fill(0, 125, 0);
                text(shufplayers[i].speed, 345, py);
                fill(0, 0, 125);
                text(shufplayers[i].stamina, 370, py);
                fill(0, 0, 0);
                if (!shufplayers[i].cpuControlled) {
                    shufplayers[i].trainingScore = (shufplayers[i].strength + shufplayers[i].speed + shufplayers[i].stamina) / 3;
                }
                text("Training Score: " + Math.floor(shufplayers[i].trainingScore), 400, py);
            }
            textAlign(CENTER, CENTER);
            fill(0, 0, 0, 120);
            noStroke();
            rect(300, textPositions[playerNum], 330, 20, 5);
            fill(0, 255, 0);
            textSize(20);
            text("Click to start the match.", 300, textPositions[playerNum]);
            textFont(createFont("AvenirNext-UltraLight"));
            if (clicked) { 
                mapSeed = round(random(0.5, 5.4999999));
                LoadMap();
                SetColors(colorNum);
                scene = "MapLoading";
                startMapTransition = false;
                frameCount = 0;
            }
            break;
        case "MapLoading":
            switch (mapSeed) {
                case 1:
                    image(imgs.bcg1, 0, 0);
                    break;
                case 2:
                    image(imgs.bcg2, 0, 0);
                    break;
                case 3:
                    image(imgs.bcg3, 0, 0);
                    break;
                case 4:
                    image(imgs.bcg4, 0, 0);
                    break;
                case 5:
                    image(imgs.bcg5, 0, 0);
                    break;
            }
            fill(0, 0, 0);
            textSize(56);
            textFont(createFont("Avenir"));
            text("Map: " + mapNames[mapSeed - 1], loadTransitionPos[0], 200);
            text("Map Size: " + mapSizes[mapSeed - 1], 300, loadTransitionPos[1]);
            textFont(createFont("AvenirNext-UltraLight"));
            if (frameCount > 100) {
                scene = "Play";
                borderDist = dists[mapSeed - 1];
                startingPlayers = players.length;
                paused = true;
                matchtime = 0;
            }
            if (loadTransitionPos[0] < 300) {
                loadTransitionPos[0] += 6;
            }
            if (loadTransitionPos[1] > 400) {
                loadTransitionPos[1] -= 6;
            }
            if (loadTransitionPos[0] >= 300 && loadTransitionPos[1] <= 400) {
                startMapTransition = true;
            }
            if (!startMapTransition) {
                frameCount = 0;
            }
            break;
        case "Welcome":
            colorBackground();
            fill(255, 0, 0);
            textSize(60);
            fill(255, 0, 0);
            text("WELCOME BACK!", 300, 200);
            fill(0, 0, 255);
            text("Click to continue.", 300, 400);
            if (clicked) {
                scene = "Menu";
            }
            break;
        case "Play":
            splicinds = [];
            background(255, 255, 255);
            matchtime++;
            if (paused) {
                sf += 0.005;
            }
            if (sf >= 1 && paused) {
                sf = 1;
                paused = false;
                countdown = 3;
            }
            //paused = true;
            if (!paused) {
                //countdown -= 1 / 50;
            }
            background(255, 255, 255);
            colortf *= 0.98;
            resetMatrix();
            pushMatrix();
            //scale(0.1);
            translate(300, 300);
            rotate(Player1.ang);
            translate(-300, -300);
            invtf *= 0.98;
            if (mouseY > 390) {
                invtf *= 1.2;
            }
            background(255, 255, 255);
            //pushMatrix();
            resetMatrix();
            translate(300, 0);
            scale(sf);
            translate(-300, 0);
            pushMatrix();
            
            translate(300, 300);
            rotate(Player1.ang);
            translate(-300, -300);
            translate(300 - Player1.x, 300 - Player1.y);
            if (!paused) {
                DrawMap();
            }
            else {
                DrawMap(false, true);
            }
             resetMatrix();
             translate(300, 0);
            scale(sf);
            translate(-300, 0);
             //scale(0.1);
             translate(300, 300);
            rotate(Player1.ang);
            translate(-300, -300);
             translate(300 - Player1.x, 300 - Player1.y);
             
            //if (!displayed) {
            if (scene === "Play") {
                for (var i = 0 ; i < players.length ; i++) {
                    if (players[i].cpuControlled) {
                        if (!paused && countdown <= 0) {
                            players[i].display();
                        }
                        else {
                            players[i].draww();
                        }
                        //players[i].draww();
                    }
                }
            }
            //}
            //popMatrix();
           
            /*for (var i = 0 ; i < arrows.length ; i++) {
                resetMatrix();
                translate(300, 300);
                rotate(Player1.ang);
                translate(-300, -300);
                translate(300 - Player1.x, 300 - Player1.y);
                arrows[i].update();
            }*/
            resetMatrix();
             translate(300, 300);
            rotate(Player1.ang);
            translate(-300, -300);
             translate(300 - Player1.x, 300 - Player1.y);
            Player1.display();
            
             resetMatrix();
            for (var i = 0 ; i < 3; i++) {
                for (var j = 0 ; j < 9; j++) {
                    noStroke();
                    resetMatrix();
                    
                    invInd = i * 9 + j;
                    invW = 45;
                    invH = 45;
                    invX = 60 + j * 60 - invW / 2;
                    invY = 440 + i * 60 - invH / 2;
                    invIcon = itemList.indexOf(Player1.inventory[invInd]);
                    if (mouseX > invX && mouseX < invX + invW && mouseY > invY && mouseY < invY + invH && invIcon > 0 && !displayed) {
                        fill(210, 210, 210);
                        cursor(HAND);
                        if (clicked && Player1.weaponInd !== invInd) {
                            Player1.weapon = Player1.inventory[invInd];
                            Player1.weaponInd = invInd;
                        }
                        else if (clicked) {
                            Player1.weapon = "";
                            Player1.weaponInd = "No Weapon";
                        }
                        
                        if (clicked && invIcon >= 9 && invIcon <= 12) {
                            if (invIcon === 9) {
                                Player1.health += round(random(0.6, 25.4));
                            }
                            if (invIcon === 10) {
                                Player1.health += round(random(24.6, 50.4));
                            }
                            if (invIcon === 11) {
                                Player1.health += round(random(49.6, 99.4));
                            }
                            if (invIcon === 12) {
                                Player1.health = 100;
                                cleric = true;
                            }
                            Player1.inventory[invInd] = "Empty Space";
                            Player1.weapon = "";
                            Player1.weaponInd = "No Weapon";
                        }
                        if (clicked && invIcon >= 14 && invIcon <= 19) {
                            Player1.weapon = "";
                            Player1.weaponInd = "No Weapon";
                            Player1.color = invIcon - 13;
                            Player1.polyColor = false;
                            Player1.inventory[invInd] = "Empty Space";
                            Player1.colorTime = 120;
                            colortf = 255;
                        }
                        if (clicked && invIcon === 27) {
                            Player1.thirst += random(30, 40);
                            Player1.inventory[invInd] = "Empty Bottle";
                            Player1.weapon = "";
                            Player1.weaponInd = "No Weapon";
                        }
                        if (clicked && invIcon >= 28 && invIcon <= 30) {
                            if (invIcon === 28) {
                                Player1.hunger += random(35, 55);
                                Player1.matchStamina += 40;
                            }
                            if (invIcon === 29) {
                                if (Math.random(1) < 0.2) {
                                    Player1.hunger += random(2, 5);
                                    Player1.matchStamina += 3;
                                }
                                else {
                                    Player1.poisoned = true;
                                }
                            }
                            if (invIcon === 30) {
                                if (Math.random(1) < 0.95) {
                                    Player1.hunger += random(15, 20);
                                    Player1.matchStamina += 18;
                                }
                                else {
                                    Player1.poisoned = true;
                                }
                            }
                            Player1.inventory[invInd] = "Empty Space";
                            Player1.weapon = "";
                            Player1.weaponInd = "No Weapon";
                        }
                        fill(210, 210, 210, invtf);
                    }
                    noStroke();
                    if (Player1.weaponInd === invInd) {
                        strokeWeight(3);
                        stroke(0, 0, 0, invtf);
                    }
                    fill(200, 200, 200, invtf);
                    
                    rect(invX + invW / 2, invY + invH / 2, 45, 45, 5);
                    if (invIcon === 8) {
                        fill(0, 0, 0);
                        noStroke();
                        strokeWeight(1.5);
                        rect(invX + invW, invY, 20, 20, 2);
                        fill(255, 255, 255);
                        textFont(createFont("monospace"));
                        textSize(10);
                        text("x" + Player1.arrowcount[invInd], invX + invW, invY);
                        textFont(createFont("AvenirNext-UltraLight"));
                    }
                    drawIcon(invIcon, invX, invY, 45, invtf, [200, 200, 200, invtf]);
                    
                    resetMatrix();
                }
            }
            if (!displayed) {
                if (Player1.weaponIcon === 13) {
                    if (Player1.healthCount[Player1.weaponInd] <= 0) {
                        stroke(255, 0, 0);
                        fill(255, 255, 255, invtf);
                        rect(300, 400, 200, 20, 20);
                        fill(0, 0, 0);
                        textSize(20);
                        textFont(createFont("Avenir"));
                        text("Heal", 300, 400);
                        if (mouseX > 200 && mouseX < 400 && mouseY > 390 && mouseY < 410) {
                            cursor(HAND);
                            if (clicked) {
                                Player1.health += round(random(19.6, 60.4));
                                Player1.healthCount[Player1.weaponInd] = 60;
                            }
                        }
                    }
                    else if (Player1.healthCount[Player1.weaponInd]) {
                        fill(0, 0, 0);
                        textSize(20);
                        textFont(createFont("Avenir"));
                        text("Cooldown: " + Player1.healthCount[Player1.weaponInd] + " seconds", 300, 400);
                        textFont(createFont("AvenirNext-UltraLight"));
                    }
                }
                textFont(createFont("AvenirNext-UltraLight"));
                if (Player1.weaponIcon === 20) {
                    if (Player1.polyjuiceCount[Player1.weaponInd] <= 0) {
                        for (var i = 0 ; i < colorNum ; i++) {
                            fill(colors[i]);
                            var polyX = (600 / colorNum) * (i + 0.5);
                            var polyY = 400;
                            ellipse(polyX, polyY, 20, 20);
                            if (dist(mouseX, mouseY, polyX, polyY) < 10) {
                                cursor(HAND);
                                if (clicked) {
                                    Player1.color = i + 1;
                                    Player1.polyColor = true;
                                    colortf = 255;
                                    Player1.polyjuiceCount[Player1.weaponInd] = 30;
                                }
                            }
                        }
                    }
                    else if (Player1.polyjuiceCount[Player1.weaponInd]) {
                        fill(0, 0, 0);
                        textSize(20);
                        textFont(createFont("Avenir"));
                        text("Cooldown: " + Player1.polyjuiceCount[Player1.weaponInd] + " seconds", 300, 400);
                        textFont(createFont("AvenirNext-UltraLight"));
                    }
                }
            }
            //if (Pla
            for (var i = 0 ; i < 3; i++) {
                for (var j = 0 ; j < 9; j++) {
                    resetMatrix();
                    invInd = i * 9 + j;
                    invW = 45;
                    invH = 45;
                    invX = 60 + j * 60 - invW / 2;
                    invY = 440 + i * 60 - invH / 2;
                    invIcon = itemList.indexOf(Player1.inventory[invInd]);
                    if (mouseX > invX && mouseX < invX + invW && mouseY > invY && mouseY < invY + invH && invIcon > 0 && !displayed) {
                        fill(255, 255, 255, 200);
                        stroke(125, 125, 125);
                        strokeWeight(1);
                        rectMode(LEFT);
                        if (j < 6) {
                            rect(mouseX, mouseY - heights[invIcon] - 20, 200, heights[invIcon] + 20, 3);
                        }
                        else {
                            rect(mouseX - 200, mouseY - heights[invIcon] - 20, 200, heights[invIcon] + 20, 3);
                        }
                        rectMode(CENTER);
                        fill(0, 0, 0);
                        textFont(createFont("Avenir"));
                        textAlign(LEFT, TOP);
                        textSize(12);
                        if (j < 6) {
                            text(itemList[invIcon] + "\n" + itemDescriptions[invIcon], mouseX + 5, mouseY - heights[invIcon] - 20, 190, heights[invIcon] + 20);
                        }
                        else {
                            text(itemList[invIcon] + "\n" + itemDescriptions[invIcon], mouseX - 195, mouseY - heights[invIcon] - 20, 190, heights[invIcon] + 20);
                        }
                        textFont(createFont("AvenirNext-UltraLight"));
                        textAlign(CENTER, CENTER);
                    }
                }
            }
            if (displayed) {
                fill(125, 125, 125, 200);
                noStroke();
                rect(300, 300, 600, 600);
                fill(125, 125, 125);
                fill(200, 200, 200);
                noStroke();
                for (var i = 0 ; i < chestItems.length / 9; i++) {
                    for (var j = 0 ; j < Math.min(chestItems.length - i * 9, 9); j++) {
                        noStroke();
                        var chestInd = i * 9 + j;
                        var chestW = 45;
                        var chestH = 45;
                        var chestX = 60 + j * 60 - chestW / 2;
                        var chestY = 120 + i * 60 - chestH / 2;
                        var chestIcon = itemList.indexOf(chestItems[chestInd]);
                        fill(200, 200, 200);
                        if (mouseX > chestX && mouseX < chestX + chestW && mouseY > chestY && mouseY < chestY + chestH && chestIcon > 0) {
                            fill(210, 210, 210);
                            cursor(HAND);
                            if (clicked && !Player1.inventoryFull && chestItems[chestInd] !== "Sheath of Arrows") {
                                Player1.inventory[Player1.lastEmptySpace] = chestItems[chestInd];
                                chests[dispChestInd].items[chestInd] = "Empty Space";
                            }
                            else if (clicked && chestItems[chestInd] === "Sheath of Arrows") {
                                var arrowFound = false;
                                Player1.arrow = true;
                                for (var k = 0 ; k < Player1.inventory.length ; k++) {
                                    if (Player1.inventory[k] === "Sheath of Arrows" && !arrowFound) {
                                        Player1.arrowcount[k] += 10;
                                        arrowFound = true;
                                        chests[dispChestInd].items[chestInd] = "Empty Space";
                                    }
                                }
                                if (!arrowFound) {
                                    if (Player1.inventoryFull) {
                                        Player1.arrow = false;
                                    }
                                    else {
                                        Player1.inventory[Player1.lastEmptySpace] = "Sheath of Arrows";
                                        Player1.arrow = true;
                                        Player1.arrowcount[Player1.lastEmptySpace] = 10;
                                        chests[dispChestInd].items[chestInd] = "Empty Space";
                                    }
                                }
                            }
                        }
                        rect(60 + j * 60, 120 + i * 60, 45, 45, 5);
                        drawIcon(chestIcon, chestX, chestY, 45, 255, [200, 200, 200]);
                        resetMatrix();
                    }
                }
                fill(100, 100, 100);
                fill(0, 0, 0);
                textSize(18);
                textFont(createFont("Avenir"));
                text("Press \"X\" or the button on the left to exit", 300, 50);
                fill(100, 100, 100);
                if (dist(mouseX, mouseY, 50, 50) < 25) {
                    fill(110, 110, 110);
                    cursor(HAND);
                    if (clicked) {
                        displayed = false;
                        chests[dispChestInd].displayed = false;
                    }
                }
                if (keys[88]) {
                    displayed = false;
                    chests[dispChestInd].displayed = false;
                }
                textFont(createFont("AvenirNext-UltraLight"));
                noStroke();
                ellipse(50, 50, 50, 50);
                stroke(0, 0, 0);
                strokeWeight(5);
                line(40, 40, 60, 60);
                line(60, 40, 40, 60);
                for (var i = 0 ; i < chestItems.length / 9; i++) {
                    for (var j = 0 ; j < Math.min(chestItems.length - i * 9, 9); j++) {
                        var chestInd = i * 9 + j;
                        var chestW = 45;
                        var chestH = 45;
                        var chestX = 60 + j * 60 - chestW / 2;
                        var chestY = 120 + i * 60 - chestH / 2;
                        var chestIcon = itemList.indexOf(chestItems[chestInd]);
                        if (mouseX > chestX && mouseX < chestX + chestW && mouseY > chestY && mouseY < chestY + chestH && chestIcon > 0) {
                            fill(255, 255, 255, 200);
                            stroke(125, 125, 125);
                            strokeWeight(1);
                            rectMode(LEFT);
                            if (j < 6) {
                                if (i > 1) {
                                    rect(mouseX, mouseY - heights[chestIcon] - 20, 200, heights[chestIcon] + 20, 3);
                                }
                                else {
                                    rect(mouseX, mouseY, 200, heights[chestIcon] + 20, 3);
                                }
                            }
                            else {
                                if (i > 1) {
                                    rect(mouseX - 200, mouseY - heights[chestIcon] - 20, 200, heights[chestIcon] + 20, 3);
                                }
                                else {
                                    rect(mouseX - 200, mouseY, 200, heights[chestIcon] + 20, 3);
                                }
                            }
                            rectMode(CENTER);
                            fill(0, 0, 0);
                            textFont(createFont("Avenir"));
                            textAlign(LEFT, TOP);
                            textSize(12);
                            if (j < 6) {
                                if (i > 1) {
                                    text(itemList[chestIcon] + "\n" + itemDescriptions[chestIcon], mouseX + 5, mouseY - heights[chestIcon] - 20, 190, heights[chestIcon] + 20);
                                }
                                else {
                                    text(itemList[chestIcon] + "\n" + itemDescriptions[chestIcon], mouseX + 5, mouseY, 190, heights[chestIcon] + 20);
                                }
                            }
                            else {
                                if (i > 1) {
                                    text(itemList[chestIcon] + "\n" + itemDescriptions[chestIcon], mouseX - 195, mouseY - heights[chestIcon] - 20, 190, heights[chestIcon] + 20);
                                }
                                else {
                                    text(itemList[chestIcon] + "\n" + itemDescriptions[chestIcon], mouseX - 195, mouseY, 190, heights[chestIcon] + 20);
                                }
                            }
                            textFont(createFont("AvenirNext-UltraLight"));
                            textAlign(CENTER, CENTER);
                        }
                    }
                }
                
                
                
            }
            invtf = constrain(invtf, 50, 255);
            Player1.health = constrain(Player1.health, 0, 100);
            if (!displayed) {
                drawBar(300, 15, Player1.health, color(255, 0, 0), "Health");
                drawBar(300, 40, Math.ceil(Player1.hunger), color(222, 194, 111), "Hunger");
                drawBar(300, 65, Math.ceil(Player1.thirst), color(0, 125, 125), "Thirst");
                drawBar(300, 90, Math.ceil(Player1.matchStamina), color(107, 103, 224), "Stamina");
                fill(0, 0, 0);
                for (var i = 0 ; i < lakes.length ; i++) {
                    if ((dist(Player1.x, Player1.y, lakes[i][0], lakes[i][1]) < lakes[i][2] / 2 + 50) && (dist(Player1.x, Player1.y, lakes[i][0], lakes[i][1]) > lakes[i][3] / 2 || !lakes[i][3]) && (!Player1.inBoat)) {
                        fill(0,0, 0);
                        textSize(20);
                        textFont(createFont("Avenir"));
                        text("You have reached a lake.", 300, 320);
                        if (Player1.gotBottle) {
                            fill(240, 240, 240, 230);
                            if (mouseX > 240 && mouseX < 360 && mouseY > 345 && mouseY < 395) {
                                cursor(HAND);
                                if (clicked) {
                                    Player1.inventory[Player1.bottleInd] = "Bottle of Water";
                                    Player1.weapon = "No Weapon";
                                    Player1.weaponInd = "";
                                }
                            }
                            rect(300, 370, 120, 50, 5);
                            fill(0, 0, 0);
                            text("Fill Bottle", 300, 370);
                        }
                        else if (Player1.bottle) {
                            text("To fill up your water bottle,\nselect that item in your inventory.", 300, 370);
                        }
                        textFont(createFont("AvenirNext-UltraLight"));
                    }
                }
                /*if (Player1.thirst < 10 && !Player1.bodyOfWater) {
                    text("You are dying of thirst.", 300, 50);
                    if (frameCount % 5 === 0) {
                        Player1.health --;
                        if (Player1.health <= 0) {
                            Player1.killInd = "Thirst";
                        }
                    }
                }
                else if (Player1.thirst < 25 && !Player1.bodyOfWater) {
                    text("You are very thirsty.", 300, 50);
                }
                else if (Player1.thirst < 50 && !Player1.bodyOfWater) {
                    text("You are getting thirsty. Go to a body of freshwater to avoid taking damage.", 300, 50);
                }*/
                fill(colors[Player1.color - 1]);
                stroke(0, 0, 0);
                rect(0, 0, 200, 200);
                fill(0, 0, 0);
                textSize(20);
                textFont(createFont("Avenir"));
                text("Color:\n" + colorWords[Player1.color] + "\n" + Player1.strColorTime, 50, 50);
                textFont(createFont("AvenirNext-UltraLight"));
                fill(0, 0, 0);
                textSize(60);
                textFont(createFont("Avenir"));
                text(players.length, 565, 30);
                textSize(10);
                text("players\nremain", 565, 70);
                textFont(createFont("monospace"));
                textFont(createFont("AvenirNext-UltraLight"));
            }
            fill(arrColors[Player1.color - 1][0], arrColors[Player1.color - 1][1], arrColors[Player1.color - 1][2], colortf);
            noStroke();
            rect(300, 300, 600, 600);
            fill(0, 0, 0, 155);
            textSize(150);
            textFont(createFont("Avenir"));
            if (!paused && countdown > 0) {
                text(Math.ceil(countdown), 300, 300);
            }
            textFont(createFont("AvenirNext-UltraLight"));
            //Player1.killInd = 1;
            //scene = "Eliminated";
            if (scene === "Play" && players.length === 1) {
                if (scene !== "Final") {
                    frequentPlayer ++;
                    if (startingPlayers === 48) {
                        ultraWinner ++;
                    }
                    Player1.dist /= 10;
                }
                scene = "Final";
                
                targetIncr = [convertStrength(Player1.kills, playerNum), convertSpeed(Player1.dist), convertStamina(Player1.surtime)];
                elimd = true;
                thestatincr = 0;
                menushow = false;
                stframe = 0;
                stgone = false;
                win = true;
                playerplace = 1;
            }
            for (var i = splicinds.length - 1 ; i >= 0 ; i--) {
                players.splice(splicinds[i], 1);
            }
            if ((borderDist > 1200 && matchtime > 3000 && mapSeed !== 4) || (borderDist > 2400 && matchtime > 3000 && mapSeed === 4)) {
                borderDist -= 4;
            }
            break;
        case "Final":
            if (playerplace < playerNum / 2 && !ticks[5]) {
                money += (playerNum / 2 - playerplace) * 48;
                ticks[5] = true;
            }
            for (var i = messages.length - 1 ; i >= 0 ; i--) {
                if (messages[i][0].split(" ")[1] !== "Achievement") {
                    messages.splice(i, 1);
                }
            }
            matchPlayed = true;
            if (win) {
                combos[convertCombo(startingPlayers, startingColors)] = true;
                winner = true;
                if (Player1.surtime <= 300) {
                    fastWorker = true;
                }
            }
            if (Player1.kills) {
                amateurHunter = true;
            }
            if (Player1.kills >= 3) {
                hunter = true;
            }
            if (Player1.kills >= 10 && !ticks[8]) {
                savage2 = true;
                Player1.totalKills += Player1.kills;
                ticks[8] = true;
            }
            if (Player1.totalKills >= 20) {
                savage = true;
            }
            if (playerplace <= startingPlayers / 2) {
                moreThanHalf = true;
            }
            if (startingPlayers === 48 && playerplace <= 32) {
                crowded = true;
            }
            if (startingPlayers >= 24 && playerplace <= 5) {
                topOfTheCharts = true;
            }
            if (playerplace <= 3 && Player1.kills === 0) {
                pacifist = true;
            }
            thestats = [Player1.strength, Player1.speed, Player1.stamina];
            thestat = thestats[thestatincr];
            colorBackground();
            fill(255, 0, 0);
            if (win) {
                fill(0, 255, 0);
            }
            textFont(createFont("Avenir"));
            textSize(80);
            if (win) {
                
                text("YOU WON!", 300, 50);
            }
            else {
                textSize(40);
                text("You placed in " + playerplace + pref(playerplace) + " place!", 300, 50);
            }
            
            textSize(50);
            text("Congratulations!", 300, 120);
            fill(125, 0, 0);
            textSize(40);
            
            text("Kills: " + Player1.kills, 300, 200);
            fill(0, 125, 0);
            if (thestatincr >= 1) {
                text("Distance Traveled: " + Math.floor(Player1.dist) + " meters", 300, 280);
            }
            fill(0, 0, 125);
            if (thestatincr >= 2) {
                text("Time Survived: " + Player1.surtime + " seconds", 300, 360);
            }
            noFill();
            stroke(0, 0, 0);
            strokeWeight(3);
            rectMode(LEFT);
            if (thestat < 12) {
                rect(190, 430, 360, 30);
            }
            noStroke();
            fill(stcol[thestatincr]);
            if (thestat < 12) {
                rect(190, 432, (Player1.incr[thestatincr] / statlevels[thestat]) * 360, 27);
            }
            rectMode(CENTER);
            fill(stcol[thestatincr]);
            ellipse(150, 445, 90, 90);
            textAlign(LEFT, CENTER);
            textSize(23);
            fill(stcol[thestatincr]);
            text(nam[thestatincr], 5, 445);
            textAlign(CENTER, CENTER);
            fill(0, 0, 0);
            textSize(40);
            text(thestat, 150, 445);
            if (menushow) {
                fill(0, 0, 0, 55);
                if (mouseX > 225 && mouseX < 375 && mouseY > 510 && mouseY < 590) {
                    cursor(HAND);
                    fill(0, 0, 0, 75);
                    if (clicked) {
                        chests = [];
                        scene = "Menu";
                    }
                }
                rect(300, 550, 150, 80, 20);
                fill(0, 0, 255);
                textSize(32);
                textFont(createFont("monospace"));
                text("Menu", 300, 550);
                textFont(createFont("AvenirNext-UltraLight"));
            }
            if (targetIncr[thestatincr] > 0) {
                Player1.incr[thestatincr] += 1;
                targetIncr[thestatincr] -= 1;
            }
            if (targetIncr[thestatincr] <= 0 || thestat >= 12) {
                if (!stgone) {
                    stgone = true;
                    stframe = 0;
                }
                else if (stframe < 50) {
                    stframe ++;
                }
                else if (thestatincr <= 1) {
                    thestatincr ++;
                    stgone = false;
                    stframe = 0;
                }
                else {
                    menushow = true;
                }
                //targetIncr = 
            }
            if (Player1.incr[0] > statlevels[Player1.strength]) {
                Player1.incr[0] -= statlevels[Player1.strength];
                Player1.strength ++;
            }
            if (Player1.incr[1] > statlevels[Player1.speed]) {
                Player1.incr[1] -= statlevels[Player1.speed];
                Player1.speed ++;
            }
            if (Player1.incr[2] > statlevels[Player1.stamina]) {
                Player1.incr[2] -= statlevels[Player1.stamina];
                Player1.stamina ++;
            }
            break;
        case "Eliminated":
            noStroke();
            for (var i = messages.length - 1 ; i >= 0 ; i--) {
                if (messages[i][0].split(" ")[1] !== "Achievement") {
                    messages.splice(i, 1);
                }
            }
            background(255, 255, 255);
            resetMatrix();
            pushMatrix();
            translate(300, 300);
            rotate(Player1.ang);
            translate(-300, -300);
            translate(300 - Player1.x, 300 - Player1.y);
            DrawMap();
            resetMatrix();
            fill(0, 0, 0, 200);
            noStroke();
            rect(300, 300, 600, 600);
            textSize(50);
            textFont(createFont("Avenir"));
            fill(255, 0, 0);
            if (Player1.killInd === "Color") {
                text("You entered an unauthorized\ncolor zone.", 300, 75);
            }
            else if (Player1.killInd === "Thirst") {
                text("You died of thirst.", 300, 75);
            }
            else if (Player1.killInd === "Hunger") {
                text("You died of hunger.", 300, 75);
            }
            else if (Player1.killInd === "Poison") {
                text("You ate a poisonous berry.", 300, 75);
            }
            else if (Player1.killInd === "Border") {
                textSize(35);
                text("You were eliminated by the\nshrinking map.", 300, 75);
            }
            else if (Player1.killInd === "Fang") {
                text("You were eliminated by a dark and powerful fang.", 300, 75);
            }
            else {
                text("You were eliminated by:", 300, 50);
                fill(255, 255, 255);
                text(players[Player1.killInd].name + "!", 300, 100);
            }
            fill(255, 255, 255);
            text("You placed in", 300, 250);
            textSize(70);
            text(players.length + pref(players.length) + " Place!", 300, 320);
            textFont(createFont("AvenirNext-UltraLight"));
            fill(0, 0, 0, 55);
            if (mouseX > 225 && mouseX < 375 && mouseY > 470 && mouseY < 530) {
                cursor(HAND);
                fill(0, 0, 0, 75);
                if (clicked) {
                    elimd = true;
                    if (scene !== "Final") {
                        Player1.dist /= 10;
                        frequentPlayer ++;
                    }
                    
                    scene = "Final";
                    targetIncr = [convertStrength(Player1.kills, playerNum), convertSpeed(Player1.dist), convertStamina(Player1.surtime)];
                    
                    thestatincr = 0;
                    menushow = false;
                    stframe = 0;
                    stgone = false;
                    win = false;
                    playerplace = players.length;
                }
            }
            noStroke();
            rect(300, 500, 150, 60, 20);
            textFont(createFont("monospace"));
            textSize(20);
            fill(0, 0, 255);
            text("Continue", 300, 500);
            textFont(createFont("AvenirNext-UltraLight"));
            break;
        case "ScaledMap":
            if (ticks[0] === 0) {
                mapSeed = 1;
                LoadMap();
                SetColors(6);
                translate(300, 300);
                scale(0.03);
                translate(-300, -300);
                DrawMap(true);
                ticks[0] = 1;
            }
            break;
        case "Gallery":
            background(0, 0, 0, 0);
            switch (clickFrame) {
                case 1:
                    image(imgs.bcg1, 0, 0);
                    break;
                case 2:
                    image(imgs.bcg2, 0, 0);
                    break;
                case 3:
                    image(imgs.bcg3, 0, 0);
                    break;
                case 4:
                    image(imgs.bcg4, 0, 0);
                    break;
                case 5:
                    image(imgs.bcg5, 0, 0);
                    break;
            }
            if (clicked) {
                clickFrame++;
            }
            break;
    }
    drawMessages();
};

draw = function() {
    cursor(ARROW);
    LoadGame();
    if (matchPlayed) {
        unlock(0);
    }
    if (rookieBuyer) {
        unlock(1);
    }
    if (coloring) {
        unlock(2);
    }
    if (moreThanHalf) {
        unlock(3);
    }
    if (amateurHunter) {
        unlock(4);
    }
    if (crowded) {
        unlock(5);
    }
    if (frequentPlayer >= 5) {
        unlock(6);
    }
    if (money >= 500) {
        unlock(7);
    }
    if (cleric) {
        unlock(8);
    }
    if (topOfTheCharts) {
        unlock(9);
    }
    if (hunter) {
        unlock(10);
    }
    if (winner) {
        unlock(12);
    }
    bigBuyer = 0;
    veryBigBuyer = 0;
    for (var i = 0 ; i < owned.length ; i++) {
        if (owned[i]) {
            bigBuyer ++;
            veryBigBuyer ++;
        }
    }
    if (bigBuyer >= 3) {
        unlock(13);
    }
    if (dragonsPowers) {
        unlock(14);
    }
    if (pacifist) {
        unlock(15);
    }
    if (savage >= 20) {
        unlock(16);
    }
    if (ultraWinner >= 3) {
        unlock(18);
    }
    if (veryBigBuyer >= 6) {
        unlock(19);
    }
    if (mythicalPowers) {
        unlock(20);
    }
    if (fastWorker) {
        unlock(21);
    }
    if (savage2) {
        unlock(22);
    }
    clicked = false;
    if (keys[32] && !spacePressed) {
        spacePressed = true;
        spaceClicked = true;
    } 
    else if (keys[32]) {
        spaceClicked = false;
    }
    else {
        spaceClicked = false;
        spacePressed = false;
    }
    resetMatrix();
    if (clicked && displayed) {
        chestClicked = true;
    }
    if (clicked && !displayed) {
        chestClicked = false;
    }
    fill(255, 0, 0);
    textSize(60);
    //text(this.__frameRate, 300, 300);
    spacepressed = false;
    ps = second();
    if (scene !== oldscene) {
        transitioning = true;
        mode = 0;
        diagpos = 300;
        choptf = 0;
        timg = round(random(-0.4, 4.4));
    }
    if (transitioning) {
        if (mode === 0) {
            if (diagpos > 0) {
                diagpos -= tincr;
            }
            else {
                mode = 1;
                newscene = scene;
            }
        }
        else {
            if (choptf < 300) {
                choptf += tincr;
            }
            else {
                transitioning = false;
            }
        }
        if (mode === 0) {
            translate(-diagpos, 0);
            rotate(45);
            
            image(imgs2[timg][0], 0, 0);
            resetMatrix();
            translate(0, -diagpos);
            translate(600, 0);
            rotate(45);
            translate(-600, 0);
            translate(600 - 300*Math.sqrt(2), 0);
            
            image(imgs2[timg][1], 0, 0);
            resetMatrix();
            translate(diagpos, 0);
            translate(600, 600);
            rotate(45);
            translate(-600, -600);
            translate((600 - 300*Math.sqrt(2)), (600 - 300*Math.sqrt(2)));
            image(imgs2[timg][2], 0, 0);
            resetMatrix();
            translate(0, diagpos);
            translate(0, 600);
            rotate(45);
            translate(0, -600);
            translate(0, (600 - 300*Math.sqrt(2)));
            image(imgs2[timg][3], 0, 0);
        }
        else {
            resetMatrix();
            //background(255, 255, 255);
            for (var i = 0 ; i < imgs1[timg].length ; i++) {
                image(imgs1[timg][i], orgpos[i][0] + choptf * dir[i][0], orgpos[i][1] + choptf * dir[i][1]);
            }
        }
    }
    messageTick++;
    fill(255, 0, 0);
    textSize(40);
    //text(this.__frameRate, 300, 300);
    achl = [];
    for (var i = 0 ; i < achievements.length ; i++) {
        achl.push(achievements[i][2]);
    }
    Player1.Pinventory = [];
    for (var i = 0 ; i < Player1.inventory.length ; i++) {
        if (Player1.inventory[i] !== "Empty Space") {
            Player1.Pinventory.push("\"" + Player1.inventory[i] + "\"");
        }
        else {
            Player1.Pinventory.push("\"ES\"");
        }
    }
    sc = [scene === "Play", achl, Player1.x, Player1.y, Player1.Pinventory, Player1.strength, Player1.speed, Player1.stamina, owned, money, money + 797, Player1.incr[0], Player1.incr[1], Player1.incr[2], Player1.totalKills, frequentPlayer, ultraWinner];
    if (saving || (keys[16] && pclicked)) {
        println("Here is your save code! Paste the following into line 8\nvar saveCode = [" + sc + "];");
    }
    pclicked = false;
};





//Wow, over 6000 lines of code!
